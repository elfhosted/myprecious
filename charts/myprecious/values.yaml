# This controls whether our automation will auto-release this to stable during the daily maint window
safeToRelease: false

# false by default means the FSN cluster (so no migrations)
location:
  enabled: false
zurgling:
  enabled: false
debridling:
  enabled: false
sidekick:
  enabled: false
decypharrreplacezurg:
  enabled: false

# false by default
volsync:
  enabled: false
  restic_repository:
  restic_password:
  aws_access_key_id:
  aws_secret_access_key:

# Set these to the default if nothing else is set
storageclass:
  rwx:
    name: ceph-filesystem-ssd
    accessMode: ReadWriteMany
    volumeSnapshotClassName: ceph-filesystem
  rwo:
    name: ceph-block-ssd
    accessMode: ReadWriteOnce
    volumeSnapshotClassName: ceph-block

# These control the egress bandwidth of the semi-dedi products
hobbit_streamer_podAnnotations: &hobbit_streamer_podAnnotations
  kubernetes.io/egress-bandwidth: "250M"
ranger_streamer_podAnnotations: &ranger_streamer_podAnnotations
  kubernetes.io/egress-bandwidth: "500M"
halfling_streamer_podAnnotations: &halfling_streamer_podAnnotations
  kubernetes.io/egress-bandwidth: "1000M"
nazgul_streamer_podAnnotations: &nazgul_streamer_podAnnotations
  kubernetes.io/egress-bandwidth: "1000M"

# These control the requests used to "anchor" a stack to a particular dedicated node. The following defaults can be overridden on a per-cluster basis:
hobbit_zurg_resources: &hobbit_zurg_resources
  requests:
    cpu: "1.8"
    memory: 30Mi
  limits:
    cpu: "2"
    memory: 4Gi

ranger_zurg_resources: &ranger_zurg_resources
  requests:
    cpu: "3500m"
    memory: 30Mi
  limits:
    cpu: "4"
    memory: 4Gi

halfling_zurg_resources: &halfling_zurg_resources
  requests:
    cpu: "7"
    memory: 30Mi
  limits:
    cpu: "8"
    memory: 4Gi

nazgul_zurg_resources: &nazgul_zurg_resources
  requests:
    cpu: "7"
    memory: 30Mi
  limits:
    cpu: "16"
    memory: 4Gi


# These allow us to manage RAM usage on streamers
hobbit_streamer_resources: &hobbit_streamer_resources
  requests:
    cpu: "10m"
    memory: 30Mi
  limits:
    cpu: "2"
    memory: 4Gi

ranger_streamer_resources: &ranger_streamer_resources
  requests:
    cpu: 10m
    memory: 30Mi
  limits:
    cpu: 4
    memory: 4Gi

# Giving more than 4 CPU to a streamer is unwise regardless
halfling_streamer_resources: &halfling_streamer_resources
  requests:
    cpu: 10m
    memory: 30Mi
  limits:
    cpu: 4
    memory: 4Gi

nazgul_streamer_resources: &nazgul_streamer_resources
  requests:
    cpu: 10m
    memory: 30Mi
  limits:
    cpu: 4
    memory: 4Gi

# sets the user's base dns domain
dns_domain: elfhosted.com

tooling_image: &tooling_image ghcr.io/elfhosted/tooling:focal-20250404@sha256:e3a3d41c2c59c8844b5f4abc8fb3b3e5444904649a5a10f74db81b79ad8c2fe3

# all RD pods have to exist with zurg - make this soft for now
standard_affinity: &standard_affinity
  podAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app.elfhosted.com/role
          operator: In
          values:
          - nodefinder # use nodefinder in the absence of zurg...
      topologyKey: "kubernetes.io/hostname"

standard_anti_affinity: &standard_anti_affinity
  podAntiAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app.elfhosted.com/role
          operator: In
          values:
          - nodefinder
      topologyKey: "kubernetes.io/hostname"

dedicated_affinity: &dedicated_affinity
  podAffinity:
    requiredDuringSchedulingIgnoredDuringExecution:
    - labelSelector:
        matchExpressions:
        - key: app.elfhosted.com/role
          operator: In
          values:
          - nodefinder # use nodefinder in the absence of zurg...
      topologyKey: "kubernetes.io/hostname"

standard_tolerations: &standard_tolerations

hobbit_tolerations: &hobbit_tolerations

# Set minimal requests so that pods can co-exist with streamers
hobbit_resources: &hobbit_resources
  requests:
    cpu: "1m"
    memory: "16Mi"
  limits:
    cpu: "1"
    memory: 4Gi

ranger_resources: &ranger_resources
  requests:
    cpu: "1m"
    memory: "16Mi"
  limits:
    cpu: "2"
    memory: 8Gi

volumespec_ephemeral_volume_100g: &volumespec_ephemeral_volume_100g
  ephemeral:
    volumeClaimTemplate:
      metadata:
        labels:
          velero.io/exclude-from-backup: "true"
      spec:
        accessModes: [ "ReadWriteOnce" ]
        storageClassName: "topolvm-provisioner-thin"
        resources:
          requests:
            storage: 100Gi

volumespec_ephemeral_volume_500g: &volumespec_ephemeral_volume_500g
  ephemeral:
    volumeClaimTemplate:
      metadata:
        labels:
          velero.io/exclude-from-backup: "true"
      spec:
        accessModes: [ "ReadWriteOnce" ]
        storageClassName: "topolvm-provisioner-thin"
        resources:
          requests:
            storage: 500Gi

volumespec_ephemeral_volume_50g: &volumespec_ephemeral_volume_50g
  ephemeral:
    volumeClaimTemplate:
      metadata:
        labels:
          velero.io/exclude-from-backup: "true"
      spec:
        accessModes: [ "ReadWriteOnce" ]
        storageClassName: "topolvm-provisioner-thin"
        resources:
          requests:
            storage: 50Gi

# And this makes the media / rclone mounts tidier.
rclonemountrealdebridzurg: &rclonemountrealdebridzurg
  enabled: false
  type: custom
  volumeSpec:
    persistentVolumeClaim:
      claimName: realdebrid-zurg
  mountPath: /storage/realdebrid-zurg
rclonemountdebridlink: &rclonemountdebridlink
  enabled: false
  type: custom
  volumeSpec:
    persistentVolumeClaim:
      claimName: debridlink
  mountPath: /storage/debridlink
rclonemountalldebrid: &rclonemountalldebrid
  enabled: false
  type: custom
  volumeSpec:
    persistentVolumeClaim:
      claimName: alldebrid
  mountPath: /storage/alldebrid
rclonemountpremiumize: &rclonemountpremiumize
  enabled: false
  type: custom
  volumeSpec:
    persistentVolumeClaim:
      claimName: premiumize
  mountPath: /storage/premiumize
rclonemounttorbox: &rclonemounttorbox
  enabled: false
  type: custom
  volumeSpec:
    persistentVolumeClaim:
      claimName: torbox
  mountPath: /storage/torbox
rclonemountdebridav: &rclonemountdebridav
  enabled: false 
  type: custom
  volumeSpec:
    persistentVolumeClaim:
      claimName: debridav
  mountPath: /storage/debridav    
rclone: &rclone
  enabled: true # everyone gets an rclone mount
  type: custom
  volumeSpec:
    persistentVolumeClaim:
      claimName: rclone
  mountPath: /storage/rclone  

# This simplfies the process of adding all the optional mounts to every app
storagemounts: &storagemounts
  rclone: *rclone
  rclonemountrealdebridzurg: *rclonemountrealdebridzurg
  rclonemountdebridlink: *rclonemountdebridlink
  rclonemountalldebrid: *rclonemountalldebrid
  rclonemountpremiumize: *rclonemountpremiumize
  rclonemounttorbox: *rclonemounttorbox
  rclonemountdebridav: *rclonemountdebridav
  tmp: &tmp
    enabled: true
    type: emptyDir
    mountPath: /tmp
  symlinks: &symlinks
    enabled: true
    type: custom
    volumeSpec:
      persistentVolumeClaim:
        claimName: symlinks
    mountPath: /storage/symlinks
  backup: &backup
    enabled: true
    type: custom
    volumeSpec:
      persistentVolumeClaim:
        claimName: backup

# The entire bootstrap sidecar/additionalcontainer
default_resources: &default_resources
  requests:
    cpu: 0m
    memory: 1Mi
    # ephemeral-storage: 50Mi
  limits:
    cpu: 1
    memory: 4Gi # just a safety net against bugs!
    # ephemeral-storage: 2Gi # a safety net against node ephemeral space exhaustion

default_securitycontext: &default_securitycontext
  seccompProfile:
    type: RuntimeDefault
  readOnlyRootFilesystem: true
  allowPrivilegeEscalation: false
  runAsUser: 568
  runAsGroup: 568
  capabilities:
    drop:
    - ALL

speedtest_securitycontext: &speedtest_securitycontext
  seccompProfile:
    type: RuntimeDefault
  readOnlyRootFilesystem: false
  allowPrivilegeEscalation: false
  runAsUser: 101
  runAsGroup: 101
  capabilities:
    drop:
    - ALL

# We use this to provide env not only to bootstrap, but also to the torrent clients which use elfvpn
# it's necessary since the wireguard configs are in S3
bootstrap_env: &bootstrap_env
- name: AWS_ACCESS_KEY_ID
  valueFrom:
    secretKeyRef:
      key: access-key-id
      name: b2-elfhosted-config-ro
- name: AWS_SECRET_ACCESS_KEY
  valueFrom:
    secretKeyRef:
      key: secret-key
      name: b2-elfhosted-config-ro
- name: S3_ENDPOINT_URL
  value: https://s3.us-west-000.backblazeb2.com
- name: K8S_APP_NAME
  valueFrom:
    fieldRef:
      fieldPath: metadata.labels['app.kubernetes.io/name']
- name: ELF_APP_NAME
  valueFrom:
    fieldRef:
      fieldPath: metadata.labels['app.elfhosted.com/name']

bootstrap: &bootstrap
  image: *tooling_image
  imagePullPolicy: IfNotPresent
  command:
  - /bin/bash
  - -c
  - |
    set -e

    # Allows us to use app.elfhosted.com/name, but fall back to app.kubernetes.io/name if the former doesn't exist
    if [[ -z "$ELF_APP_NAME" ]]; then
      ELF_APP_NAME=$K8S_APP_NAME
    fi

    # look for commands - we match specific names in order of least-destructive
    TIMESTAMP_NOW=$(date +%s)
    if [[ -f /etc/elfbot/elfbot_pause ]]; then
      TIMESTAMP_COMMAND=$(cat /etc/elfbot/elfbot_pause)
      if [[ -f /etc/elfbot/elfbot_pause_duration ]]; then
        PAUSE_DURATION=$(cat /etc/elfbot/elfbot_pause_duration)
      else
        PAUSE_DURATION=5 # default to 5 minutes
      fi
      TIMESTAMP_DIFF=$((TIMESTAMP_NOW-TIMESTAMP_COMMAND))
      if [[ $TIMESTAMP_DIFF -lt 300 ]]; then
        COMMAND=pause
      fi
    fi

    # If no command is set, then move onto the next possibility
    if [[ -f /etc/elfbot/elfbot_backup && -z "$COMMAND" ]]; then
      TIMESTAMP_COMMAND=$(cat /etc/elfbot/elfbot_backup)
      TIMESTAMP_DIFF=$((TIMESTAMP_NOW-TIMESTAMP_COMMAND))
      if [[ $TIMESTAMP_DIFF -lt 300 ]]; then
        COMMAND=backup
      fi
    fi


    # If no command is set, then move onto the next possibility
    if [[ -f /etc/elfbot/elfbot_reset && -z "$COMMAND" ]]; then
      TIMESTAMP_COMMAND=$(cat /etc/elfbot/elfbot_reset)
      TIMESTAMP_DIFF=$((TIMESTAMP_NOW-TIMESTAMP_COMMAND))
      if [[ $TIMESTAMP_DIFF -lt 300 ]]; then
        COMMAND=reset
      fi
    fi

    case $COMMAND in

      "pause")
        echo "Recent pause command found, sleeping ${PAUSE_DURATION}m.."
        sleep ${PAUSE_DURATION}m
        ;;

      "reset")

        # Safety check - if /config/homer exists, we've not mounted /config properly and are about to wipe out EVERYTHING
        if [ -e "/config/homer" ]; then
            echo "The path /config/homer exists. Exiting."
            exit 1
        fi      
        echo "Recent reset command found, resetting"
        rm -rf /config/*
        ;;

      "backup")
        TIMESTAMP=$(printf '%(%Y-%m-%d--%H-%M)T\n' -1)
        echo "Recent backup command found, backing up to /storage/backup/${ELF_APP_NAME}-${TIMESTAMP}"
        cp -rfp /config /storage/backup/$ELF_APP_NAME-$TIMESTAMP
        ;;


    esac

    if [[ ! -f /config/i-am-bootstrapped ]]
    then
      echo "Bootstrapping from goldilocks config..."
      s5cmd sync s3://elfhosted-config/goldilocks/$ELF_APP_NAME/* /config/
      touch /config/i-am-bootstrapped
    fi

  volumeMounts:
  - mountPath: /etc/elfbot
    name: elfbot
  - mountPath: /config
    name: config
  - mountPath: /storage/backup
    name: backup
  - mountPath: /tmp
    name: tmp
  env: *bootstrap_env
  resources: *default_resources
  securityContext: *default_securitycontext

# provide a default
userId: 1

# our VPN loadbalancerIP
torrentLoadBalancerIP: 10.0.42.101

# these are the "exposed" services which allow users to override SSO
# by themselves, they do nothing, but they allow us to selectively disable
# SSO on ingressroutes, or to use non-standard API keys in Homer
radarrexposed:
  enabled: false
  apikey: 041776c8d5f74bf295aa486d9d51c33a
radarr4kexposed:
  enabled: false
  apikey: 7da5d4ba79804527b78a78b68c7a0781
sonarrexposed:
  enabled: false
  apikey: a6f1c7d07fab4be49c5c1cb545f85a76
sonarr4kexposed:
  enabled: false
  apikey: e4f93c115169484bbed19821f7ac8e49
lidarrexposed:
  enabled: false
  apikey: 0e68e28531a249659737513d3102bfe9
readarrexposed:
  enabled: false
  apikey: 74b033ff59964011b8a32c014fdb9b68
readarraudioexposed:
  enabled: false
  apikey: 8496cefe2c6b46ee921e18caddf6a943
prowlarrexposed:
  enabled: false
  apikey: c53bc3bd17c645c3a457e5342a02cd66
bazarrexposed:
  enabled: false
  apikey: 94ab8212a12378fa5333cbf75a3c0390
bazarr4kexposed:
  enabled: false
  apikey: 393bda5f898886a2b87413e6452313af
qbittorrentexposed:
  enabled: false
rdtclientexposed:
  enabled: false
rutorrentexposed:
  enabled: false
sabnzbdexposed:
  enabled: false
  apikey: 8flkbru7ncdps3dzzgk48q2msz41m4on
nzbgetexposed:
  enabled: false
mylarrexposed:
  enabled: false
  apikey: 0f97f6a7f352c63eb43fcb7e53ea9d8f
rivenexposed:
  enabled: false
  apikey: 1nMZNC0Cg6UP7sblvFirUi9Sad4ga84u  
tunarrexposed:
  enabled: false
cometexposed:
  enabled: false  
aiostreamsexposed:
  enabled: false    
davioexposed:
  enabled: false  
jackettioexposed:
  enabled: false  
knightcrawlerexposed:
  enabled: false  
mediafusionexposed:
  enabled: false
stremthruexposed:
  enabled: false    
youriptvexposed:
  enabled: false
threadfinexposed:
  enabled: false
dispatcharrexposed:
  enabled: false  
zurgexposed:
  enabled: false
elfassessment:
  enabled: false
uptimekumacustomdomain:
  enabled: false
mattermostcustomdomain:
  enabled: false
vaultwardencustomdomain:
  enabled: false
jellyseerrcustomdomain:
  enabled: false
overseerrcustomdomain:
  enabled: false
plexcustomdomain:
  enabled: false
jellyfincustomdomain:
  enabled: false
embycustomdomain:
  enabled: false
flixiocustomdomain:
  enabled: false
pairdropcustomdomain:
  enabled: false
gotosocialcustomdomain:
  enabled: false  
blueskypdscustomdomain:
  enabled: false    
peertubecustomdomain:
  enabled: false     
actualcustomdomain:
  enabled: false   
actualapicustomdomain:
  enabled: false  
wgercustomdomain:
  enabled: false

rutorrentgluetun: &rutorrent
  enabled: false
  automountServiceAccountToken: false
  image:
      repository: ghcr.io/elfhosted/rutorrent
      tag: 5.1.7-7.2@sha256:b5138140095c158f72e386fd7284add7e3b5349a251a5594666bd7a62b9a75a8
  imagePullSecrets:
  - name: ghcr-io-elfhosted      
  podLabels:
    app.elfhosted.com/name: rutorrent
  podAnnotations:
    elfbot.elfhosted.com/name: "ruTorrent"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/rutorrent.png"
    kubernetes.io/egress-bandwidth: "150M"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,rutorrent-config,rutorrent-gluetun-config,elfbot-rutorrent" # Reload the deployment every time the yaml config changes
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    # runAsUser: 568 # enforced in env vars
    # runAsGroup: 568
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false
  envFrom:
  - configMapRef:
      name: elfbot-rutorrent
      optional: true
  # we need the injected initcontainer to run as root, so we can't change the pod-level uid/gid
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    # runAsUser: 568 # s6's fault
    # runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"

  persistence:
    <<: *storagemounts
    tmp:
      enabled: true
      type: custom
      mountPath: /tmp
      volumeSpec: *volumespec_ephemeral_volume_100g
    config:
      enabled: true
      type: custom
      mountPath: /data/rtorrent/
      subPath: rutorrent
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-rutorrent
          optional: true
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory
    port-range: # Used for dynamic port-forwarding
      enabled: true
      type: emptyDir
      mountPath: /port-range
      sizeLimit: 1Gi
    custom-rtlocal:
      enabled: "true"
      mountPath: "/.rtlocal.rc-elfhosted"
      subPath: ".rtlocal.rc-elfhosted"
      type: "custom"
      volumeSpec:
        configMap:
          name: rutorrent-config
    custom-rtorrentrc:
      enabled: "true"
      mountPath: "/.rtorrent.rc-elfhosted"
      subPath: ".rtorrent.rc-elfhosted"
      type: "custom"
      volumeSpec:
        configMap:
          name: rutorrent-config
    custom-s6-init-05:
      enabled: "true"
      mountPath: "/etc/cont-init.d/05-apply-elfhosted-config.sh"
      subPath: "05-apply-elfhosted-config.sh"
      type: "custom"
      volumeSpec:
        configMap:
          name: rutorrent-config
          defaultMode: 0755
    custom-s6-init-06:
      enabled: "true"
      mountPath: "/etc/cont-init.d/02-wait-for-vpn.sh"
      subPath: "02-wait-for-vpn.sh"
      type: "custom"
      volumeSpec:
        configMap:
          name: rutorrent-config
          defaultMode: 0755
    custom-s6-init-07:
      enabled: "true"
      mountPath: "/etc/cont-init.d/03-set-inbound-port.sh"
      subPath: "03-set-inbound-port.sh "
      type: "custom"
      volumeSpec:
        configMap:
          name: rutorrent-config
          defaultMode: 0755
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: false # necessary for probes, but probes aren't working with vpn addon currently
  resources:
    requests:
      cpu: 100m
      memory: 512Mi
    limits:
      cpu: 500m
      memory: 1200Mi
  env:
    # -- Set the container timezone
    PUID: 568
    GUID: 568
    RUTORRENT_PORT: 8080 # necessary for health checks
    # S6_READ_ONLY_ROOT: 1 # this seems to break rutorrent :(
    WAIT_FOR_VPN: "true"
    PORT_FILE: /data/rtorrent/forwarded-port
    WAN_IP_CMD: 'curl -s ifconfig.me'
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: rutorrent
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # If the VPN_ENDPOINT_IP is set, but is not an IP address, then convert it to one
        if [[ ! -z "$VPN_ENDPOINT_IP" ]]
          then
          if echo "$VPN_ENDPOINT_IP" | egrep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
          then
              echo "No changes, VPN_ENDPOINT_IP is an IP"
          else
              # only create the file if DNS lookup succeeds
              dig +short $VPN_ENDPOINT_IP && dig +short $VPN_ENDPOINT_IP | tail -n1 > /shared/VPN_ENDPOINT_IP
          fi
        fi
      volumeMounts:
      - mountPath: /shared
        name: shared
      securityContext: *default_securitycontext
      resources: *default_resources
      envFrom:
      - configMapRef:
          name: rutorrent-gluetun-config
  addons:
    vpn: &rutorrent_addons_vpn
      enabled: true
      type: gluetun
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      securityContext:
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      envFrom:
      - configMapRef:
          name: rutorrent-gluetun-config
      additionalVolumeMounts:
      - mountPath: /config
        name: config
        subPath: rutorrent
      config: # We have to set this to null so that we can override with our own config

      # The scripts that get run when the VPN connection opens/closes are defined here.
      # The default scripts will write a string to represent the current connection state to a file.
      # Our qBittorrent image has a feature that can wait for this file to contain the word 'connected' before actually starting the application.
      scripts:
        up: |-
          #!/bin/ash
          echo "connected" > /shared/vpnstatus

        down: |-
          #!/bin/ash
          echo "disconnected" > /shared/vpnstatus
  additionalContainers:
    # Use this to provied proxied access to arrs
    mam-helper:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /usr/bin/dumb-init
      - /bin/bash
      - -c
      - |
        set -e
        set -x

        echo "Waiting for VPN to be connected..."
        while ! grep -s -q "connected" /shared/vpnstatus; do
            # Also account for gluetun-style http controller
            if (curl -s http://localhost:8042/v1/openvpn/status | grep -q running); then
                break
            fi
            echo "VPN not connected"
            sleep 2
        done
        echo "VPN Connected, processing cookies..."

        # If we have a cookie already, try to use it
        if [[ -f /config/mam/saved.cookies ]]; then
          curl -c /config/mam/saved.cookies -b /config/mam/saved.cookies https://t.myanonamouse.net/json/dynamicSeedbox.php  -o /config/mam/mam_id-curl-output.log
        fi

        # Now whether that worked or not, look for /config/mam/mam_id
        mkdir -p /config/mam
        while [ 1 ]; do
          if [[ -f /config/mam/mam_id ]]; then
            curl -c /config/mam/saved.cookies -b "mam_id=$(cat /config/mam/mam_id)" https://t.myanonamouse.net/json/dynamicSeedbox.php -o /config/mam/mam_id-curl-output.log
            mv /config/mam/mam_id /config/mam/mam_id_processed
          fi
          sleep 1m
        done
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: rutorrent
      - mountPath: /shared
        name: shared
      resources: *default_resources
      securityContext: *default_securitycontext

rutorrentpia:
  <<: *rutorrent
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,rutorrent-config,rutorrent-pia-config,elfbot-rutorrent" # Reload the deployment every time the yaml config changes
  addons:
    vpn:
      <<: *rutorrent_addons_vpn
      gluetun:
        image:
          repository: thrnz/docker-wireguard-pia
          tag: latest
      envFrom:  
      - configMapRef:
          name: rutorrent-pia-config
      - configMapRef:
          name: elfbot-rutorrent
          optional: true              
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: rutorrent
      - mountPath: /tmp
        name: tmp

qbittorrentgluetun: &qbittorrent
  podLabels:
    app.elfhosted.com/name: qbittorrent
  podAnnotations:
    elfbot.elfhosted.com/name: "qBittorrent"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/qbittorrent.png"
    kubernetes.io/egress-bandwidth: "150M"
  enabled: false
  automountServiceAccountToken: false
  image:
    registry: ghcr.io
    repository: elfhosted/qbittorrent
    tag: 5.0.2@sha256:7ff09d6a5ca2267f78161fb46eeafaf5b2af7806288fe7f3d2dfed2521374e3d
  priorityClassName: tenant-bulk
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't seem to work well with entrypoint
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-qbittorrent,qbittorrent-gluetun-config"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    <<: *storagemounts
    tmp:
      enabled: true
      type: custom
      mountPath: /tmp
      volumeSpec: *volumespec_ephemeral_volume_100g
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: qbittorrent
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-qbittorrent
          optional: true
    elfscripts:
      enabled: "true"
      mountPath: "/elfscripts/"
      type: "custom"
      volumeSpec:
        configMap:
          name: qbittorrent-elfscripts
          defaultMode: 0755
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
      nameOverride: spanky
  env:
    # -- Set the container timezone
    TZ: UTC
    HOME: /config
    XDG_CONFIG_HOME: /config
    XDG_DATA_HOME: /config
    WAIT_FOR_VPN: "true"
  envFrom:
  - configMapRef:
      name: elfbot-qbittorrent
      optional: true
  extraEnvVars:
  - name: PORT_FILE
    valueFrom:
      configMapKeyRef:
        name: qbittorrent-gluetun-config
        key: PORT_FILE
    optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: qbittorrent
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # Remove the lockfile if it exists
        if [[ -f /config/qBittorrent/lockfile ]]; then
          rm /config/qBittorrent/lockfile
        fi

        mkdir -p /config/qBittorrent/torrent_files/complete
        mkdir -p /config/qBittorrent/torrent_files/incomplete

        # Enforce 1:1 seeding ratio, and then delete
        sed -i  "s/Session\\\GlobalMaxRatio=.*/Session\\\GlobalMaxRatio=1/" /config/qBittorrent/qBittorrent.conf

        # Permit TCP only
        sed -i  "s/Session\\\BTProtocol=.*/Session\\\BTProtocol=TCP/" /config/qBittorrent/qBittorrent.conf

        # Disable CSRF protection so that Homer can show qBit stats
        sed -i  "s/WebUI\\\CSRFProtection=.*/WebUI\\\CSRFProtection=false/" /config/qBittorrent/qBittorrent.conf

        # Insist on tun0
        sed -i  "s/Session\\\Interface=.*/Session\\\Interface=tun0/" /config/qBittorrent/qBittorrent.conf
        sed -i  "s/Session\\\InterfaceName=.*/Session\\\InterfaceName=tun0/" /config/qBittorrent/qBittorrent.conf

        # If the VPN_ENDPOINT_IP is set, but is not an IP address, then convert it to one
        if [[ ! -z "$VPN_ENDPOINT_IP" ]]
          then
          if echo "$VPN_ENDPOINT_IP" | egrep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
          then
              echo "No changes, VPN_ENDPOINT_IP is an IP"
          else
              # only create the file if DNS lookup succeeds
              dig +short $VPN_ENDPOINT_IP && dig +short $VPN_ENDPOINT_IP | tail -n1 > /shared/VPN_ENDPOINT_IP
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: qbittorrent
      - mountPath: /shared
        name: shared
      securityContext: *default_securitycontext
      resources: *default_resources
      envFrom:
      - configMapRef:
          name: qbittorrent-gluetun-config
  additionalContainers:
    # Use this to provied proxied access to arrs
    mam-helper:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /usr/bin/dumb-init
      - /bin/bash
      - -c
      - |
        set -e
        set -x

        echo "Waiting for VPN to be connected..."
        while ! grep -s -q "connected" /shared/vpnstatus; do
            # Also account for gluetun-style http controller
            if (curl -s http://localhost:8042/v1/openvpn/status | grep -q running); then
                break
            fi
            echo "VPN not connected"
            sleep 2
        done
        echo "VPN Connected, processing cookies..."

        # If we have a cookie already, try to use it
        if [[ -f /config/mam/saved.cookies ]]; then
          curl -c /config/mam/saved.cookies -b /config/mam/saved.cookies https://t.myanonamouse.net/json/dynamicSeedbox.php  -o /config/mam/mam_id-curl-output.log
        fi

        # Now whether that worked or not, look for /config/mam/mam_id
        mkdir -p /config/mam
        while [ 1 ]; do
          if [[ -f /config/mam/mam_id ]]; then
            curl -c /config/mam/saved.cookies -b "mam_id=$(cat /config/mam/mam_id)" https://t.myanonamouse.net/json/dynamicSeedbox.php -o /config/mam/mam_id-curl-output.log
            mv /config/mam/mam_id /config/mam/mam_id_processed
          fi
          sleep 1m
        done
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: qbittorrent
      - mountPath: /shared
        name: shared
      resources: *default_resources
      securityContext: *default_securitycontext
  resources:
    requests:
      cpu: 100m
      memory: 512Mi
      ephemeral-storage: 50Mi
    limits:
      cpu: 500m
      memory: 2Gi # .2 GB for headroom
      ephemeral-storage: 100Mi # a safety net against node ephemeral space exhaustion
  addons:
    vpn: &qbittorrent_addons_vpn
      enabled: true
      type: gluetun
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      securityContext:
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      envFrom:
      - configMapRef:
          name: qbittorrent-gluetun-config
      additionalVolumeMounts:
      - mountPath: /config
        name: config
        subPath: qbittorrent
      config: # We have to set this to null so that we can override with our own config

      # The scripts that get run when the VPN connection opens/closes are defined here.
      # The default scripts will write a string to represent the current connection state to a file.
      # Our qBittorrent image has a feature that can wait for this file to contain the word 'connected' before actually starting the application.
      scripts:
        up: |-
          #!/bin/ash
          echo "connected" > /shared/vpnstatus

        down: |-
          #!/bin/ash
          echo "disconnected" > /shared/vpnstatus


# Custom service for pia
qbittorrentpia:
  <<: *qbittorrent
  env:
    PORT_FILE: /config/forwarded-port
    WAIT_FOR_VPN: "true"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-qbittorrent,qbittorrent-pia-config"
  addons:
    vpn:
      <<: *qbittorrent_addons_vpn
      gluetun:
        image:
          repository: thrnz/docker-wireguard-pia
          tag: latest
      envFrom:
      - configMapRef:
          name: qbittorrent-pia-config
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: qbittorrent
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # Remove the lockfile if it exists
        if [[ -f /config/qBittorrent/lockfile ]]; then
          rm /config/qBittorrent/lockfile
        fi

        mkdir -p /config/qBittorrent/torrent_files/complete
        mkdir -p /config/qBittorrent/torrent_files/incomplete

        # Enforce 1:1 seeding ratio, and then delete
        sed -i  "s/Session\\\GlobalMaxRatio=.*/Session\\\GlobalMaxRatio=1/" /config/qBittorrent/qBittorrent.conf

        # Permit TCP only
        sed -i  "s/Session\\\BTProtocol=.*/Session\\\BTProtocol=TCP/" /config/qBittorrent/qBittorrent.conf

        # Disable CSRF protection so that Homer can show qBit stats
        sed -i  "s/WebUI\\\CSRFProtection=.*/WebUI\\\CSRFProtection=false/" /config/qBittorrent/qBittorrent.conf

        # Insist on tun0
        sed -i  "s/Session\\\Interface=.*/Session\\\Interface=tun0/" /config/qBittorrent/qBittorrent.conf
        sed -i  "s/Session\\\InterfaceName=.*/Session\\\InterfaceName=tun0/" /config/qBittorrent/qBittorrent.conf

        # If the VPN_ENDPOINT_IP is set, but is not an IP address, then convert it to one
        if [[ ! -z "$VPN_ENDPOINT_IP" ]]
          then
          if echo "$VPN_ENDPOINT_IP" | egrep -E '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}'
          then
              echo "No changes, VPN_ENDPOINT_IP is an IP"
          else
              # only create the file if DNS lookup succeeds
              dig +short $VPN_ENDPOINT_IP && dig +short $VPN_ENDPOINT_IP | tail -n1 > /shared/VPN_ENDPOINT_IP
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: qbittorrent
      - mountPath: /shared
        name: shared
      securityContext: *default_securitycontext
      resources: *default_resources

nzbget:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/nzbget
    tag: 25.2@sha256:aab5814cc7a89ca4ad04b62d8e7b98725b15697bf711c9982bbcd3fc55d1aab1
  priorityClassName: tenant-bulk
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-nzbget"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: nzbget
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    tmp:
      enabled: true
      type: custom
      mountPath: /tmp
      volumeSpec: *volumespec_ephemeral_volume_100g
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-nzbget
          optional: true

  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 6789
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: nzbget
      - mountPath: /tmp
        name: tmp

sabnzbd:
  enabled: false
  hostname: sabnzbd # required to prevent whitelisting requirement per https://sabnzbd.org/wiki/extra/hostname-check.html
  podLabels:
    app.elfhosted.com/class: nzb
  image:
    registry: ghcr.io
    repository: elfhosted/sabnzbd
    tag: 4.3.3@sha256:af2ef54052d0d340064997aeb76bb8e612f3b47a8a0fc5c446e821a8bacd80cc
  priorityClassName: tenant-bulk
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-sabnzbd"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    runAsUser: 568
    runAsGroup: 568
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"

  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: sabnzbd
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    tmp:
      enabled: true
      type: custom
      mountPath: /tmp
      volumeSpec: *volumespec_ephemeral_volume_100g
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-sabnzbd
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: sabnzbd
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # fix host_whitelist
        sed -i  's/goldilocks/{{ .Release.Name }}/g' /config/sabnzbd.ini

        # If we've previously backed up a queue, then restore it to /tmp
        files=$(shopt -s nullglob dotglob; echo /config/queue-backup/*)
        if (( ${#files} ))
        then
          cp /config/queue-backup/* /tmp/ -rfp
          rm -rf /config/queue-backup
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: sabnzbd
      - mountPath: /tmp
        name: tmp
      env: *bootstrap_env
      securityContext: *default_securitycontext
      resources: *default_resources
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1500m # if par threads is 1, this leaves 0.5cpu for downloading
      memory: 1500Mi
  additionalContainers:
    backup-queue:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /usr/bin/dumb-init
      - /bin/bash
      - -c
      - |
        set -e
        IFS=$'\n' # in case of paths with spaces (looking at you, Plex!)

        function backupqueue_on_shutdown {
            echo "Received SIGTERM, waiting 5s for app to shut down..."
            mkdir -p /config/queue-backup
            sleep 5s

            # sync any files < 1MB
            cd /tmp
            find ./ -type f -size -1024k | rsync -avr --files-from=- /tmp /config/queue-backup
        }

        # When we terminate, perform the backup
        trap backupqueue_on_shutdown SIGTERM

        # Hang around doing nothing until terminated
        while true
        do
            echo "Waiting for SIGTERM to backup queue from /tmp"
            sleep infinity
        done
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: sabnzbd
      - mountPath: /tmp
        name: tmp
      env: *bootstrap_env
      securityContext: *default_securitycontext
      resources: *default_resources

  env:
    HOST_WHITELIST_ENTRIES: "{{ .Release.Name }}.sabnzbd.elfhosted.com"
    SABNZBD_UID: 568
    SABNZBD_GID: 568

tautulli:
  enabled: false
  image:
    registry: ghcr.io
    repository: elfhosted/tautulli
    tag: 2.15.2@sha256:214a0ef60363bf81722612732eb62830366fc2cbdbd75e39c4acca61aaae6f20
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: tautulli  
  podAnnotations:
    elfbot.elfhosted.com/name: "Tautulli"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/tautulli.png"
    elfbot.elfhosted.com/category: Manage Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-tautulli"
  # Always prefer to cohabit with zurg
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"

  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: tautulli
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-tautulli
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8181
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: tautulli
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/sh
      - -c
      - |
        set -x
        set -e

        # Clear out logs older than 24h
        if [ -d "/config/logs" ]; then
            # Find and delete files older than 7 days
            find "/config/logs" -type f -mtime +1 -exec rm -f {} \;
            echo "Files older than 1 day have been removed from /config/logs."
        fi

        # Clear out backups older than 2d
        if [ -d "/config/backups" ]; then
            # Find and delete files older than 2 days
            find "/config/backups" -type f -mtime +2 -exec rm -f {} \;
            echo "Files older than 1 day have been removed from /config/backups."
        fi
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: tautulli
      resources: *default_resources
      securityContext: *default_securitycontext

radarr: &app_radarr
  enabled: false
  podLabels:
    app.elfhosted.com/name: radarr
  podAnnotations:
    elfbot.elfhosted.com/name: "Radarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/radarr.png"    
    elfbot.elfhosted.com/category: Manage Downloads  
  priorityClassName: tenant-normal
  image:
    registry: ghcr.io
    repository: elfhosted/radarr
    tag: 5.26.2.10099@sha256:64c278e344051ea00998b2968a653c23c0f6d8ba6c4e72c6e22728d321af3f0a
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-radarr,radarr-env" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: radarr-env
  - configMapRef:
      name: elfbot-radarr
      optional: true       
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: radarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    mediacover:
      enabled: true
      type: custom
      mountPath: /config/MediaCover
      subPath: radarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: mediacovers          
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: radarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    backup:
      enabled: true
      type: custom
      mountPath: /config/Backups
      subPath: radarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-radarr
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory          
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 7878
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: radarr
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault    
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: radarr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for symlink downloads and imports
        mkdir -p /storage/symlinks/downloads/radarr
        mkdir -p /storage/symlinks/movies

        # for database to use 
        mkdir -p /config/postgresql/database

        # if /config/MediaCover exists (on the config volume), purge it, since this is now handled on a dedicated volume
        if [ -d /config/MediaCover ]; then
          rm -rf /config/MediaCover
        fi

      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      - mountPath: /config
        name: config
        subPath: radarr        
      resources: *default_resources
      securityContext: *default_securitycontext
        
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: radarr
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: radarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: radarr/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 2
          memory: 8Gi     
    database-backup:
      image: ghcr.io/elfhosted/radarr:5.26.2.10099@sha256:64c278e344051ea00998b2968a653c23c0f6d8ba6c4e72c6e22728d321af3f0a
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: radarr-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: radarr/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi
  resources:
    requests:
      cpu: 0m
      memory: 500Mi
    limits:
      cpu: 600m
      memory: 6Gi

radarr4k: &app_radarr4k
  enabled: false
  podLabels:
    app.elfhosted.com/name: radarr4k
  podAnnotations:    
    elfbot.elfhosted.com/name: "Radarr (4K)"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/radarr.png"
    elfbot.elfhosted.com/category: Manage Downloads    
  priorityClassName: tenant-normal
  image:
    registry: ghcr.io
    repository: elfhosted/radarr
    tag: 5.26.2.10099@sha256:64c278e344051ea00998b2968a653c23c0f6d8ba6c4e72c6e22728d321af3f0a
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-radarr4k,radarr4k-env" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: radarr4k-env
  - configMapRef:
      name: elfbot-radarr4k
      optional: true       
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: radarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    mediacover:
      enabled: true
      type: custom
      mountPath: /config/MediaCover
      subPath: radarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: mediacovers            
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-radarr4k
          optional: true
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: radarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    backup:
      enabled: true
      type: custom
      mountPath: /config/Backups
      subPath: radarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory          
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 7878
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config/ -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi
        
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: radarr4k
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault      
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: radarr4k
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for symlink downloads and imports
        mkdir -p /storage/symlinks/downloads/radarr4k
        mkdir -p /storage/symlinks/movies-4k

        # for database to use 
        mkdir -p /config/postgresql/database        

        # if /config/MediaCover exists (on the config volume), purge it, since this is now handled on a dedicated volume
        if [ -d /config/MediaCover ]; then
          rm -rf /config/MediaCover
        fi
        
      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      - mountPath: /config
        name: config
        subPath: radarr4k        
      resources: *default_resources
      securityContext: *default_securitycontext    
  resources:
    requests:
      cpu: 0m
      memory: 500Mi
    limits:
      cpu: 2
      memory: 6Gi
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: radarr
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: radarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: radarr4k/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi   
    database-backup:
      image: ghcr.io/elfhosted/radarr:5.26.2.10099@sha256:64c278e344051ea00998b2968a653c23c0f6d8ba6c4e72c6e22728d321af3f0a
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: radarr4k-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: radarr4k/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi            

ombi:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/ombi
    tag: 4.47.1@sha256:7346137897633f5cb3cd7d26922782f68791201e317bb3051d3f79d25242c54e
  podLabels:
    app.elfhosted.com/name: ombi
  podAnnotations:    
    elfbot.elfhosted.com/name: "Ombi"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/ombi.png"  
    elfbot.elfhosted.com/category: Manage Media    
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-ombi"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: ombi
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-ombi
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5000
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: ombi
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 3m
      memory: 150Mi
    limits:
      cpu: 2
      memory: 1Gi

huntarr: &app_huntarr
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: huntarr  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Huntarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/huntarr.png"    
    elfbot.elfhosted.com/category: Manage Downloads  
  image:
    registry: ghcr.io
    repository: elfhosted/huntarr
    tag: 8.1.15@sha256:9007538f0414ec18079c3eda38a599f4dd197172f198f2cf2602b7dcb1b1e1da
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-huntarr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: huntarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config  
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: huntarr-config   
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-huntarr
          optional: true
    app-frontend-static-data:
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
      mountPath: /app/frontend/static/data      
  initContainers:  
    aa-remove-json-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # Since v8, we don't use .json files anymore.
        # Search for .json files in /config/settings and reset if they're found
        if find /config/settings -type f -name "*.json" | grep -q .; then
            # If any .json files are found, delete everything in /config
            rm -rf /config/*
        fi
      volumeMounts:
      - mountPath: /config/
        name: config
        subPath: huntarr
      - name: example-config
        mountPath: "/bootstrap/"  
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: huntarr
      - mountPath: /tmp
        name: tmp                         
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true
      ports:
        http:
          port: 9705
  resources: *default_resources

bazarr:
  enabled: false
  image:
    registry: ghcr.io
    repository: elfhosted/bazarr
    tag: 1.5.2@sha256:c44714dd7504d72e32d4937ebae0d616738574423b3e319a74dddbeb67755c5a
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: bazarr  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Bazarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/bazarr.png"   
    elfbot.elfhosted.com/category: Manage Downloads   
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-bazarr"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    runAsUser: 568
    runAsGroup: 568
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: bazarr-config
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: bazarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-bazarr
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 6767
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: bazarr
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

bazarr4k:
  enabled: false
  image:
    registry: ghcr.io
    repository: elfhosted/bazarr
    tag: 1.5.2@sha256:c44714dd7504d72e32d4937ebae0d616738574423b3e319a74dddbeb67755c5a
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: bazarr4k  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Bazarr (4K)"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/bazarr.png"  
    elfbot.elfhosted.com/category: Manage Downloads      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-bazarr4k"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    allowPrivilegeEscalation: false
    runAsUser: 568
    runAsGroup: 568
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: bazarr4k-config
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: bazarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-bazarr4k
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 6767
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: bazarr4k
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

filebrowser:
  hostname: elfhosted
  enabled: true
  podLabels:
    app.elfhosted.com/name: filebrowser
  podAnnotations:    
    elfbot.elfhosted.com/name: "FileBrowser"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/filebrowser.png"    
    elfbot.elfhosted.com/category: Tools
  image:
    repository: ghcr.io/elfhosted/filebrowser
    tag: 2.23.0@sha256:296e3a3d08c5ca07a26350358fa2e58a597a41adb253a65bba27b557f36383e5
  podAnnotations:
    kubernetes.io/egress-bandwidth: "5M" # filebrowser is not for streaming
  # Always prefer to cohabit with zurg
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  envFrom:
  - configMapRef:
      name: filebrowser-env
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false
    allowPrivilegeEscalation: false
    runAsUser: 568
    runAsGroup: 568
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  deploymentStrategy:
    type: Recreate
    rollingUpdate: null
  controller:
    replicas: 1 # not sure we need 2 replicas anymore
    strategy: Recreate
    # rollingUpdate:
    #   unavailable: 1
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,filebrowser-elfbot-script,elfbot-filebrowser" # Reload the deployment every time the rclones change
  # We will use this to alter configmaps to trigger pod restarts
  serviceAccount:
    create: true
    name: filebrowser
  automountServiceAccountToken: true
  persistence:
    <<: *storagemounts  
    backup:
      enabled: true
      type: custom
      mountPath: /storage/backup
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    config:
      enabled: true
      type: custom
      mountPath: /storage/config
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /storage/logs
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    elfterm-state: # so auto-provisioning doesn't break
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
      mountPath: /home/elfie/.local/state
    dummy-storage: # so auto-provisioning doesn't break
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
    elfbot:
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
      mountPath: /elfbot
    elfbot-script:
      enabled: "true"
      mountPath: "/usr/local/bin/elfbot"
      subPath: "elfbot"
      type: "custom"
      volumeSpec:
        configMap:
          name: filebrowser-elfbot-script
          defaultMode: 0755
    elfbot-script-ucfirst:
      enabled: "true"
      mountPath: "/usr/local/bin/Elfbot" # make it easier for mobile users
      subPath: "elfbot"
      type: "custom"
      volumeSpec:
        configMap:
          name: filebrowser-elfbot-script
          defaultMode: 0755
    recyclarr-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: recyclarr-config
    symlinks: *symlinks
    tmp: *tmp
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080 # this allows us to run as non-root

  ingress:
    main:
      enabled: false
  initContainers:
    setup:
      image: ghcr.io/elfhosted/filebrowser:2.23.0@sha256:296e3a3d08c5ca07a26350358fa2e58a597a41adb253a65bba27b557f36383e5
      # 2.23.0@sha256:1db0f0114a169ea2a877d75c47903a6d01534340421948845d5e298c7ac7ceb4 is the last good version for TFA
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # Delete tmp db if necessary
        if [ -f /tmp/filebrowser.db ]
        then
          rm /tmp/filebrowser.db
        fi


        /filebrowser config init \
          --disable-preview-resize \
          --disable-thumbnails \
          --disable-type-detection-by-header \
          --branding.name="{{ .Release.Name }}, by ElfHosted  " \
          --branding.files=/branding \
          --branding.disableExternal \
          --auth.method=noauth \
          --lockPassword \
          --database /tmp/filebrowser.db \
          --root /storage \
          --cache-dir /tmp

        # allow zip, unzip, rar, unrar, ls, pwd, cd, mv
        /filebrowser config set --database /tmp/filebrowser.db --commands zip,unzip,rar,unrar,ls,pwd,cd,mv,cp,ln,find,echo,grep,cat,touch,tar,gzip,rm,tree,du,mlocate,updatedb,locate,elfbot,Elfbot
        # /filebrowser config set --database /tmp/filebrowser.db --shell 'vstat -c'

        # now tell filebrowser about the user (who gets authenticated via the proxy)
        /filebrowser users add 1 bogus --database /tmp/filebrowser.db

      volumeMounts:
      - mountPath: /tmp
        name: tmp
      - mountPath: /storage
        name: dummy-storage
      resources: *default_resources
      securityContext: *default_securitycontext
    copy-recyclarr-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e
        # If we don't already have an example config, create one
        if [ ! -f /config/recyclarr.yaml ];
        then
          cp /bootstrap/recyclarr.yaml /config/
        fi
      volumeMounts:
      - mountPath: /config/
        name: config
        subPath: recyclarr
      - name: recyclarr-config
        mountPath: "/bootstrap/"
      securityContext: *default_securitycontext     
  additionalContainers:
    # this container exists to watch for restarts requested by elfbot, and to use create configmaps to trigger restarts using reloader
    elfbot:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /usr/bin/dumb-init
      - /bin/bash
      - -c
      - |
        # respond to creation or modification, but not deletion
        inotifywait -m -e create -e modify --format "%f" /elfbot \
          | while read APP
            do
              # if we are force-killing the pod, then don't bother with the configmap
              if (cat /elfbot/$APP | grep -q elfbot_forcerestart); then
                echo "forcerestart requested, deleting $APP pod with --force.."
                kubectl delete pod -l app.kubernetes.io/name=$APP --force
                kubectl delete pod -l app.elfhosted.com/name=$APP --force
              else

                # put the contents of the file into the configmap which will trigger the restart
                echo command received for ${APP} : [$(cat /elfbot/$APP)]
                # create the configmap if it doesn't exist, since reloader only looks at _changes_ to configmaps
                if ! $(kubectl get configmap -n {{ .Release.Namespace }} elfbot-${APP} 2>&1 >/dev/null); then
                    kubectl create configmap -n {{ .Release.Namespace }} elfbot-${APP} --from-literal=elfbot_last_action=$(date +%s)
                    sleep 10s
                fi

                # If we were passed a key=value string in /etc/elfbot, then split it
                COMMAND=$(cat /elfbot/$APP)

                # We separate key and value with an '=', but sometimes the value may contain __another__ '=' (like Plex preferences)
                sep='='
                case $COMMAND in
                  # If we are separated by an =
                  (*"$sep"*)
                    KEY=${COMMAND%%"$sep"*}
                    VALUE=${COMMAND#*"$sep"}
                    ;;
                  # if not, we are a simple command like "backup"
                  (*)
                    KEY=$COMMAND
                    VALUE=$(date +%s)
                    ;;
                esac

                # patch the configmap with the latest key/value
                kubectl patch configmap -n {{ .Release.Namespace }} elfbot-${APP} -p "{\"data\":{\"${KEY}\":\"${VALUE}\"}}"
              fi
            done
      volumeMounts:
      - mountPath: /elfbot
        name: elfbot
      resources: *default_resources
      securityContext: *default_securitycontext
  resources:
    requests:
      cpu: 0m
      memory: 6Mi
    limits:
      cpu: 1
      memory: 1Gi


uptimekuma:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/uptime-kuma
    tag: 1.23.16@sha256:a8b71124417a5b3426154b9c800ec0f6648dee033a7bd7abde60bfbede368c58
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: uptimekuma  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Uptime Kuma"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/uptime-kuma.png"  
    elfbot.elfhosted.com/category: Tools
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-uptimekuma"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /app/data/
      subPath: uptimekuma
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-uptimekuba
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: uptimekuma
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 100m
      memory: 1Gi

privatebin:
  enabled: false
  image:
    repository: privatebin/fs
    tag: 1.7.8
  podLabels:
    app.elfhosted.com/name: privatebin
  podAnnotations:    
    elfbot.elfhosted.com/name: "PriveteBin"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/privatebin.png" 
    elfbot.elfhosted.com/category: Tools   
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-privatebin"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # crashes privatebin, TBD to determine why, and whether an emptydir /tmpfs might help
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"

  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /srv/data
      subPath: privatebin
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-privatebin
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 100m
      memory: 128Mi
  config:
    main:
      discussion: false
      opendiscussion: false
      password: true
      fileupload: true
      burnafterreadingselected: false
      defaultformatter: "plaintext"
      syntaxhighlightingtheme: "sons-of-obsidian"
      sizelimit: 1048576
      template: "bootstrap-dark"
      info: "Hosted with  by ElfHosted "
      languageselection: true
      languagedefault: "en"
      # urlshortener: "https://shortener.example.com/api?link="
      qrcode: false
      icon: "none"
      zerobincompatibility: false
      # httpwarning: true
      compression: "zlib"
    expire:
      default: "1week"
    expire_options:
      5min: 300
      10min: 600
      1hour: 3600
      1day: 86400
      1week: 604800
    formatter_options:
      plaintext: "Plain Text"
      syntaxhighlighting: "Source Code"
      markdown: "Markdown"
    traffic:
      limit: 10
      # exemptedIp: "1.2.3.4,10.10.10/24"

kapowarr:
  enabled: false
  image:
    registry: ghcr.io
    repository: elfhosted/kapowarr-dev
    tag: rolling@sha256:21142f341572dd12f614283d138499cc2030fc0d9b4dcf83c2cebd93ad216b37
  podLabels:
    app.elfhosted.com/name: kapowarr
  podAnnotations:    
    elfbot.elfhosted.com/name: "Kapowarr"
    elfbot.elfhosted.com/icon: "fas fa-comments"   
    elfbot.elfhosted.com/category: Consume Media   
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-kapowarr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # breaks kapowarr
    allowPrivilegeEscalation: false
    runAsUser: 568
    runAsGroup: 568
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  probes:
    liveness:
      enabled: false
    startup:
      enabled: false
    readiness:
      enabled: false
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: kapowarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    temp-downloads:
      enabled: true
      type: emptyDir
      mountPath: /app/temp_downloads
      sizeLimit: 50Gi
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-kapowarr
          optional: true
    tmp: *tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5656
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 2Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: kapowarr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for symlink downloads and imports
        mkdir -p /storage/symlinks/downloads/comics
        mkdir -p /storage/symlinks/comics

      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      resources: *default_resources
      securityContext: *default_securitycontext


calibreweb:
  enabled: false
  podLabels:
    app.elfhosted.com/name: calibre-web
  podAnnotations:    
    elfbot.elfhosted.com/name: "Calibre Web Automated"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/calibre-web.png"    
    elfbot.elfhosted.com/category: Consume Media 
  priorityClassName: tenant-normal  
  image:
    repository: ghcr.io/elfhosted/calibre-web-automated
    tag: 3.1.1@sha256:f3accfce85fdea9c2cc5d4703efb132d32bdba7fe7150b33d1bceea509cdca19
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-calibre-web"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    # readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"

  automountServiceAccountToken: false
  env:
    PUID: 568
    PGID: 568
    DOCKER_MODS: linuxserver/mods:universal-calibre
  envFrom:
  - configMapRef:
      name: elfbot-calibre-web
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: calibre-web
      volumeSpec:
        persistentVolumeClaim:
          claimName: config     
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-calibre-web
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      ports:
        http:
          port: 8083
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: calibre-web
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # There are symlinks pre-prepared for these
        mkdir -p /config/calibre-library
        mkdir -p /config/cwa-book-ingest

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: calibre-web
      resources: *default_resources
      securityContext: *default_securitycontext        
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

cwabookdownloader:
  enabled: false
  podLabels:
    app.elfhosted.com/name: cwa-book-downloader
  podAnnotations:    
    elfbot.elfhosted.com/name: "CWA Book Downloader"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/calibre-web-automated-book-downloader.png"    
    elfbot.elfhosted.com/category: Manage Downloads  
  priorityClassName: tenant-normal  
  image:
    repository: ghcr.io/elfhosted/cwa-downloader
    tag: rolling@sha256:582c302d4771ed125ea4b63895fe94183a0040c5e35c963b11bca3eb04921bba
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-cwa-book-downloader"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    runAsUser: 568
    runAsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  env:
    PUID: 568
    PGID: 568
    HOME: /app
  envFrom:
  - configMapRef:
      name: elfbot-cwa-book-downloader
      optional: true
  command:
  - python3 
  - app.py
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /cwa-book-ingest/
      subPath: calibre-web/cwa-book-ingest
      volumeSpec:
        persistentVolumeClaim:
          claimName: config     
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-cwa-book-downloader
          optional: true
    logs:
      enabled: true
      type: custom
      mountPath: /var/log/cwa-book-downloader/
      subPath: cwa-book-downloader
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs   
  ingress:
    main:
      enabled: false
  service:
    main:
      ports:
        http:
          port: 8084
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: calibre-web-book-downloader
      - mountPath: /tmp
        name: tmp      
  additionalContainers:
    cloudflarebypassforscraping:
      image: ghcr.io/elfhosted/cloudflarebypassforscraping@sha256:7bdf614b57f57e47a6cecdaf6048869037123e0731456ed186b5430d6bfbefad
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

lazylibrarian:
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/lazylibrarian
    tag: rolling@sha256:5095b4270cd7132983e6b6b1088a552d20051c2cf0f1f7e265c733c2af899e00
  enabled: false
  podLabels:
    app.elfhosted.com/name: lazylibrarian  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Lazy Librarian"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/lazylibrarian.png"
    elfbot.elfhosted.com/category: Manage Downloads        
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-lazylibrarian"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    runAsUser: 568
    runAsGroup: 568
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: lazylibrarian
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-lazylibrarian
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      ports:
        http:
          port: 5299
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: lazylibrarian
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 0m
      memory: 96Mi
    limits:
      cpu: 1
      memory: 1Gi

mylar:
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: mylar  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Mylar"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/mylar.png"      
    elfbot.elfhosted.com/category: Manage Downloads  
  image:
    registry: ghcr.io
    repository: elfhosted/mylar3
    tag: 0.8.2@sha256:89fdca5cc80457bde3373a6a7d69631487c41dff1e15d34bf78391eae85df0d9
  env:
    PUID: 568
    PGID: 568
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    # readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-mylar" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: mylar
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-mylar
          optional: true

  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8090
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: mylar
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

komga:
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: komga  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Komga"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/komga.png"      
    elfbot.elfhosted.com/category: Consume Media
  image:
    repository: ghcr.io/elfhosted/komga
    tag: 1.23.1@sha256:c1bdc658f72063b92b8ce917e26a1f6dac1c27a24b2eb49daf3b286b32648857
  env:
    KOMGA_CONFIGDIR: /config
    KOMGA_REMEMBERME_KEY: yesplease
    JAVA_TOOL_OPTIONS: -Xmx2g
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-komga" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: komga
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-komga
          optional: true

  ingress:
    main:
      enabled: false
  service:
    main:
      ports:
        http:
          port: 25600
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: komga
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 2Gi

kavita:
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: kavita  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Kavita"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/kavita.png"     
    elfbot.elfhosted.com/category: Consume Media
  image:
    repository: ghcr.io/elfhosted/kavita
    tag: 0.8.7@sha256:2d3eccdb29f294049b5c081ffcc20eea8e84f28eb6480db873dd83ea21e7fbb9
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-kavita" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /kavita/config
      subPath: kavita
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-kavita
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: kavita
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      ports:
        http:
          port: 5000
  resources:
    requests:
      cpu: 0m
      memory: 256Mi
    limits:
      cpu: 2
      memory: 1Gi

calibre:
  enabled: false
  podLabels:
    app.elfhosted.com/name: calibre
  podAnnotations:    
    elfbot.elfhosted.com/name: "Calibre"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/calibre.png"   
    elfbot.elfhosted.com/category: Consume Media   
  image:
    repository: quay.io/linuxserver.io/calibre
    tag: 8.7.0@sha256:88c476dc5703e89cc646e34c5836f64154978089df48d33ec9b9963e494b0847
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work with s6
    allowPrivilegeEscalation: false # do we need this too?
    # runAsUser: 568
    # runAsGroup: 568
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-calibre"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: calibre
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-calibre
          optional: true
    run: # used for s6-init with non-root
      enabled: true
      type: emptyDir
      mountPath: /run
      sizeLimit: 1Gi
  env:
    PUID: 568
    PGID: 568
    TITLE: Calibre | ElfHosted
    START_DOCKER: false
  ingress:
    main:
      enabled: false
  service:
    main:
      ports:
        http:
          port: 8080
  resources:
    requests:
      cpu: 0m
      memory: 1Gi
    limits:
      cpu: 1
      memory: 4Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: calibre
      - mountPath: /tmp
        name: tmp
  envFrom:
  - configMapRef:
      name: elfbot-calibre
      optional: true

sonarr: &app_sonarr
  enabled: false
  podLabels:
    app.elfhosted.com/name: sonarr
  podAnnotations:    
    elfbot.elfhosted.com/name: "Sonarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/sonarr.png"   
    elfbot.elfhosted.com/category: Manage Downloads   
  priorityClassName: tenant-normal
  image:
    registry: ghcr.io
    repository: elfhosted/sonarr
    tag: 4.0.15.2941@sha256:7a6a5969468d002816964ef101a459b53a461e516ff262094c72de3e73f1fff1
  imagePullSecrets:
  - name: ghcr-io-elfhosted        
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-sonarr,sonarr-env" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: sonarr-env
  - configMapRef:
      name: elfbot-sonarr
      optional: true       
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: sonarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    mediacover:
      enabled: true
      type: custom
      mountPath: /config/MediaCover
      subPath: sonarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: mediacovers            
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: sonarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    backup:
      enabled: true
      type: custom
      mountPath: /config/Backups
      subPath: sonarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-sonarr
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory      
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8989
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: sonarr
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault    
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: sonarr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for symlink downloads and imports
        mkdir -p /storage/symlinks/downloads/sonarr
        mkdir -p /storage/symlinks/series

        # for database to use 
        mkdir -p /config/postgresql/database        

        # if /config/MediaCover exists (on the config volume), purge it, since this is now handled on a dedicated volume
        if [ -d /config/MediaCover ]; then
          rm -rf /config/MediaCover
        fi
      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      - mountPath: /config
        name: config
        subPath: sonarr
      resources: *default_resources
      securityContext: *default_securitycontext     
  resources:
    requests:
      cpu: 0m
      memory: 600Mi
    limits:
      cpu: 2
      memory: 6Gi
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: sonarr
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: sonarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: sonarr/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 2Gi         
    database-backup:
      image: ghcr.io/elfhosted/sonarr:4.0.15.2941@sha256:7a6a5969468d002816964ef101a459b53a461e516ff262094c72de3e73f1fff1
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: sonarr-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: sonarr/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi            

sonarr4k: &app_sonarr4k
  enabled: false
  podLabels:
    app.elfhosted.com/name: sonarr4k
  podAnnotations:    
    elfbot.elfhosted.com/name: "Sonarr (4K)"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/sonarr.png"    
    elfbot.elfhosted.com/category: Manage Downloads  
  priorityClassName: tenant-normal
  image:
    registry: ghcr.io
    repository: elfhosted/sonarr
    tag: 4.0.15.2941@sha256:7a6a5969468d002816964ef101a459b53a461e516ff262094c72de3e73f1fff1
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-sonarr4k,sonarr4k-env" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: sonarr4k-env
  - configMapRef:
      name: elfbot-sonarr4k
      optional: true      
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: sonarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    mediacover:
      enabled: true
      type: custom
      mountPath: /config/MediaCover
      subPath: sonarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: mediacovers            
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: sonarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    backup:
      enabled: true
      type: custom
      mountPath: /config/Backups
      subPath: sonarr4k
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-sonarr4k
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory               
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8989
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: sonarr4k
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault     
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: sonarr4k
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for symlink downloads and imports
        mkdir -p /storage/symlinks/downloads/sonarr4k
        mkdir -p /storage/symlinks/series-4k

        # for database to use 
        mkdir -p /config/postgresql/database        
      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      - mountPath: /config
        name: config
        subPath: sonarr4k     
      resources: *default_resources
      securityContext: *default_securitycontext       
  resources:
    requests:
      cpu: 0m
      memory: 256Mi
    limits:
      cpu: 2
      memory: 6Gi # reduce once sqlite-to-db-migration is done
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: sonarr
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: sonarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: sonarr4k/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi 
    database-backup:
      image: ghcr.io/elfhosted/sonarr:4.0.15.2941@sha256:7a6a5969468d002816964ef101a459b53a461e516ff262094c72de3e73f1fff1
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: sonarr4k-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: sonarr4k/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi             
  probes: # need a long startup for database migrations
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 3000
        periodSeconds: 10
        successThreshold: 1
        tcpSocket:
          port: 8989
        timeoutSeconds: 1

prowlarr: &app_prowlarr
  enabled: false
  podLabels:
    app.elfhosted.com/name: prowlarr
  podAnnotations:    
    elfbot.elfhosted.com/name: "Prowlarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/prowlarr.png"    
    elfbot.elfhosted.com/category: Manage Downloads  
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/prowlarr-develop
    tag: 2.0.2.5116@sha256:e48ea91c46301c686bae7e2d6625ece0d89fd6a2853d34ac65d0624897ac0761
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    # readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-prowlarr,prowlarr-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: prowlarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: prowlarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    backup:
      enabled: true
      type: custom
      mountPath: /config/Backups
      subPath: prowlarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    run: # used for s6-init with non-root
      enabled: true
      type: emptyDir
      mountPath: /run
      sizeLimit: 1Gi
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-prowlarr
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory      
  envFrom:
  - configMapRef:
      name: prowlarr-env  
  - configMapRef:
      name: elfbot-prowlarr
      optional: true                   
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9696
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: prowlarr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/sh
      - -c
      - |
        set -x
        set -e
        # Set auth to external
        sed -i  "s|<AuthenticationMethod>None</AuthenticationMethod>|<AuthenticationMethod>External</AuthenticationMethod>|" /config/config.xml

        # for database to use 
        mkdir -p /config/postgresql/database

        # Clear out logs older than 24h
        if [ -d "/config/logs" ]; then
            # Find and delete files older than 7 days
            find "/config/logs" -type f -mtime +1 -exec rm -f {} \;
            echo "Files older than 1 day have been removed from /config/logs."
        fi

        # Get custom indexers
        mkdir -p /config/Definitions/Custom

        curl https://raw.githubusercontent.com/elfhosted/prowlarr-indexers/main/Custom/elfzilean.yml > /config/Definitions/Custom/elfzilean.yml

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: prowlarr
      resources: *default_resources
      securityContext: *default_securitycontext
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: prowlarr
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault       
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 6Gi
  env:
    S6_READ_ONLY_ROOT: 1
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: postgres
        - name: POSTGRES_DB
          value: prowlarr
        - name: POSTGRES_USER
          value: prowlarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: prowlarr/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi     
    database-backup:
      image: ghcr.io/elfhosted/prowlarr-develop:2.0.2.5116@sha256:e48ea91c46301c686bae7e2d6625ece0d89fd6a2853d34ac65d0624897ac0761 
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: prowlarr-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: prowlarr/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi
  probes: # need a long startup for database migrations, until we can bootstrap an entire database
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 3000
        periodSeconds: 10
        successThreshold: 1
        tcpSocket:
          port: 9696
        timeoutSeconds: 1  
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 300
        periodSeconds: 10
        successThreshold: 1
        tcpSocket:
          port: 9696
        timeoutSeconds: 1  
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 300
        periodSeconds: 10
        successThreshold: 1
        tcpSocket:
          port: 9696
        timeoutSeconds: 1                      


nzbhydra:
  enabled: false
  podLabels:
    app.elfhosted.com/name: nzbhydra
  podAnnotations:    
    elfbot.elfhosted.com/name: "NZBHydra"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/nzbhydra.png"    
    elfbot.elfhosted.com/category: Manage Downloads  
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/nzbhydra2
    tag: 7.16.0@sha256:05eb399bacf19719ecd46e9c134882ab29f2a64ef0f5c971a547630b7c2d9b1c
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    # readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-nzbhydra"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: nzbhydra
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: nzbhydra
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-nzbhydra
          optional: true          
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5076
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: nzbhydra
      - mountPath: /tmp
        name: tmp
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

lidarr:
  enabled: false
  image:
    registry: ghcr.io
    repository: elfhosted/lidarr-develop
    tag: 2.13.0.4664@sha256:f35f078ba42887de525392bc08cc413bd158d743b3ac0164c1c6c0c094166cc5  
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: lidarr  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Lidarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/lidarr.png"      
    elfbot.elfhosted.com/category: Manage Downloads  
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    # readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-lidarr" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: lidarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    s6:
      enabled: true
      type: emptyDir
      mountPath: /var/run/s6
      sizeLimit: 1Gi
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-lidarr
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory              
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8686
  envFrom:
  - configMapRef:
      name: lidarr-env
  - configMapRef:
      name: elfbot-lidarr
      optional: true             
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: lidarr
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault     
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: lidarr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for database to use 
        mkdir -p /config/postgresql/database

        # Set auth to external
        sed -i  "s|<AuthenticationMethod>None</AuthenticationMethod>|<AuthenticationMethod>External</AuthenticationMethod>|" /config/config.xml
        # Clean up wasteful temporary mediacover storage (Radarr will just re-download these)

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: lidarr
      resources: *default_resources
      securityContext: *default_securitycontext
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: lidarr
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: lidarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: lidarr/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi     
    database-backup:
      image: ghcr.io/elfhosted/lidarr-develop:2.13.0.4664@sha256:f35f078ba42887de525392bc08cc413bd158d743b3ac0164c1c6c0c094166cc5  
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: lidarr-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: lidarr/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi      
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 1Gi

navidrome:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/navidrome
    tag: 0.58.0@sha256:3fa59be4e1b183c350af9f0d24606bdb8714b4c956743cd6cc5bbc4b71e4d376
  priorityClassName: tenant-streaming
  podLabels:
    app.elfhosted.com/name: navidrome  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Navidrome"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/navidrome.png"    
    elfbot.elfhosted.com/category: Consume Media
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-navidrome"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  env:
    ND_MUSICFOLDER: /tmp
    ND_DATAFOLDER: /config
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: navidrome
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-navidrome
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: navidrome
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      ports:
        http:
          port: 4533
  resources:
    requests:
      cpu: 0m
      memory: 32Mi
    limits:
      cpu: 2
      memory: 1Gi

readarr:
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: readarr  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Readarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/readarr.png" 
    elfbot.elfhosted.com/category: Manage Downloads     
  image:
    registry: ghcr.io
    repository: elfhosted/readarr-develop
    tag: 0.4.18.2805@sha256:ed51f754b6baeb58d86b4fae4872dbcc8e9799c01788a9023c3d7704ae549333    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-readarr" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: readarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: readarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    tmp-readarr-backup:
      enabled: true
      type: emptyDir
      mountPath: /tmp/readarr_backup
      sizeLimit: 32Mi
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-readarr
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory
    backup:
      enabled: true
      type: custom
      mountPath: /config/Backups
      subPath: readarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup        
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8787
  envFrom:
  - configMapRef:
      name: readarr-env
  - configMapRef:
      name: elfbot-readarr
      optional: true           
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: readarr
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault     
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: readarr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for database to use 
        mkdir -p /config/postgresql/database

        # Set auth to external
        sed -i  "s|<AuthenticationMethod>None</AuthenticationMethod>|<AuthenticationMethod>External</AuthenticationMethod>|" /config/config.xml
        sed -i  "s|<AuthenticationMethod>Basic</AuthenticationMethod>|<AuthenticationMethod>External</AuthenticationMethod>|" /config/config.xml

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: readarr
      resources: *default_resources
      securityContext: *default_securitycontext
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: readarr
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: readarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: readarr/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi     
    database-backup:
      image: ghcr.io/elfhosted/readarr-develop:0.4.18.2805@sha256:ed51f754b6baeb58d86b4fae4872dbcc8e9799c01788a9023c3d7704ae549333   
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: readarr-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: readarr/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi        
  resources:
    requests:
      cpu: 0m
      memory: 256Mi
    limits:
      cpu: 2
      memory: 16Gi
  probes: # need a long startup for database migrations
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 3000
        periodSeconds: 10
        successThreshold: 1
        tcpSocket:
          port: 8787
        timeoutSeconds: 1      

readarraudio:
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: readarraudio  
  podAnnotations:    
    elfbot.elfhosted.com/name: "Readarr (Audio)"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/readarr.png"      
    elfbot.elfhosted.com/category: Manage Downloads  
  image:
    registry: ghcr.io
    repository: elfhosted/readarr-develop
    tag: 0.4.18.2805@sha256:ed51f754b6baeb58d86b4fae4872dbcc8e9799c01788a9023c3d7704ae549333   
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: readarr-env
  - configMapRef:
      name: elfbot-readarr
      optional: true    
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-readarraudio" # Reload the deployment every time the rclones change
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: readarraudio
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: readarraudio
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    tmp-readarr-backup:
      enabled: true
      type: emptyDir
      mountPath: /tmp/readarr_backup
      sizeLimit: 32Mi
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-readarraudio
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory          
    backup:
      enabled: true
      type: custom
      mountPath: /config/Backups
      subPath: readarraudio
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup        
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8787
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

        # Wipe database if it's on postgresql 16
        if [ -f /config/postgresql/database/PG_VERSION ]; then
          if grep 16 /config/postgresql/database/PG_VERSION; then
            rm -rf /config/postgresql/database/*
          fi
        fi

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: readarraudio
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault     
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: readarraudio
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # for database to use 
        mkdir -p /config/postgresql/database

        # Set auth to external
        sed -i  "s|<AuthenticationMethod>None</AuthenticationMethod>|<AuthenticationMethod>External</AuthenticationMethod>|" /config/config.xml
        sed -i  "s|<AuthenticationMethod>Basic</AuthenticationMethod>|<AuthenticationMethod>External</AuthenticationMethod>|" /config/config.xml
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: readarraudio
      resources: *default_resources
      securityContext: *default_securitycontext
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: readarr
        - name: POSTGRES_DB
          value: postgres
        - name: POSTGRES_USER
          value: readarr
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: readarr/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi     
    database-backup:
      image: ghcr.io/elfhosted/readarr-develop:0.4.18.2805@sha256:ed51f754b6baeb58d86b4fae4872dbcc8e9799c01788a9023c3d7704ae549333   
      command: [ "/database-backup.sh" ]
      envFrom:
      - configMapRef:
          name: readarr-env
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: readarr/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 100m
          memory: 1Gi         
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 16Gi
  probes: # need a long startup for database migrations
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 3000
        periodSeconds: 10
        successThreshold: 1
        tcpSocket:
          port: 8787
        timeoutSeconds: 1      

plex: &app_plex
  enabled: false
  priorityClassName: tenant-streaming
  podLabels:
    app.elfhosted.com/name: plex    
  podAnnotations:
    kubernetes.io/egress-bandwidth: "150M" # tested with _kilos in Discord on a 97Mbit remux
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/plex.png"
    elfbot.elfhosted.com/name: "Plex"
    elfbot.elfhosted.com/category: Consume Media
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: true
  podSecurityContext:
    fsGroup: 568
    runAsUser: 568
    runAsGroup: 568    
    # fsGroupChangePolicy: "Always"
    seccompProfile:
      type: Unconfined
    supplementalGroups:
    - 993
    - 44
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-zurg,elfbot-plex,elfbot-decypharr,elfbot-debridav,elfbot-imagemaid,plex-config,imagemaid-env,plex-tinyproxy-conf" # Reload the deployment every time the rclones change
  image:
    registry: ghcr.io
    repository: elfhosted/plex
    tag: 1.41.9.9961-46083195d@sha256:f273e344e77e6717254c850df69dcd59968b09f8bb243236bd7afca22432f01a
  imagePullSecrets:
  - name: ghcr-io-elfhosted      
  persistence: &app_plex_persistence
    <<: *storagemounts
    backup: &backup
      enabled: true
      type: custom
      mountPath: /backup
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/Library/Application Support/Plex Media Server/Logs
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-1g    
    phototranscoder:
      enabled: true
      mountPath: /config/Library/Application Support/Plex Media Server/Cache/PhotoTranscoder
      type: emptyDir
      sizeLimit: 50Gi
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-plex
          optional: true
    render-device: &streamer_render_device
      enabled: "true"
      type: hostPath
      hostPath: "/dev/dri"
      mountPath: "/dev/dri"
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory     
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 32400
  envFrom:
  - configMapRef:
      name: plex-config
  - secretRef:
      name: gatus-smtp-config      
  - configMapRef:
      name: elfbot-plex
      optional: true
  resources:
    requests:
      cpu: "100m"
      memory: 1Gi
    limits:
      cpu: "2" # 1.5 works, but results in buffering when playback starts, see https://github.com/elfhosted/charts/issues/501
      memory: 4Gi
  initContainers:
    restart-with-zurg:
      image: ghcr.io/elfhosted/zurg-rc:2025.07.29.0047-nightly@sha256:1a42b75a1758065b7250033758a4c957dece6510d5345e3a21255adc6ce805f7
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when zurg is updated"
    restart-with-decypharr:
      image: ghcr.io/elfhosted/decypharr:v1.0.5@sha256:b0d539fe2217cce88979e65f6982afd872579a5fbc72140c06c36bfe0e2fdf3d
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when decypharr is updated"
    restart-with-debridav:
      image: ghcr.io/elfhosted/debridav:0.10.1@sha256:67748eff91c1c318827284bb31a9f39c2ce10b22e29e58ec4f65659152fd8cfe
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when debridav is updated"        
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: plex
      - mountPath: /tmp
        name: tmp
    dbrepair:
      image: ghcr.io/elfhosted/plex:1.41.9.9961-46083195d@sha256:f273e344e77e6717254c850df69dcd59968b09f8bb243236bd7afca22432f01a
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        if [ $REPAIR_DB_ON_START == "true" ]; then
          # Repair the database if it exists
          if [ -f /config/Library/Application\ Support/Plex\ Media\ Server/Plug-in\ Support/Databases/com.plexapp.plugins.library.db ]; then
            echo "Repairing Plex database"
            /usr/local/bin/DBRepair.sh --databases /config/Library/Application\ Support/Plex\ Media\ Server/Plug-in\ Support/Databases/ --sqlite "/usr/lib/plexmediaserver/Plex SQLite" automatic
          else
            echo "No Plex database found, skipping repair"
          fi
        else
          echo "REPAIR_DB_ON_START is not set to true, skipping database repair"
        fi
      envFrom:
      - configMapRef:
          name: elfbot-plex
          optional: true        
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: plex
      - mountPath: /phototranscoder
        name: phototranscoder
      # can't use default resources because the ephemeral limit kicks out /phototranscoder later
      # resources: *default_resources
      securityContext: *default_securitycontext       
    setup-warp: &setup_warp
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        cd /shared

        # Create cloudflare account
        wgcf register --accept-tos

        # Create gluetun config
        wgcf generate -p /shared/wg0.conf

        # grab the values from the profile and put them into env vars for gluetun to consume
        echo "export WIREGUARD_PRIVATE_KEY=$(grep PrivateKey /shared/wg0.conf | cut -f3 -d' ')" > /shared/env
        echo "export WIREGUARD_PUBLIC_KEY=$(grep PublicKey /shared/wg0.conf | cut -f3 -d' ')" >> /shared/env
        echo "export WIREGUARD_ADDRESSES=$(grep Address /shared/wg0.conf | grep '/32' | cut -f3 -d' ')" >> /shared/env

        echo "export VPN_ENDPOINT_IP=$(dig +short dig +short engage.cloudflareclient.com)" >> /shared/env

      volumeMounts:
      - mountPath: /shared
        name: shared
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: false
  additionalContainers:
    speedtest:
      image: openspeedtest/latest:latest@sha256:1745e913f596fe98882b286a67751efdae74774e9caa742a4934bb056e8748d2
      imagePullPolicy: IfNotPresent
      env:
        CHANGE_CONTAINER_PORTS: "True"
        HTTP_PORT: "3002"
        HTTPS_PORT: "3003"
      securityContext: *speedtest_securitycontext
  addons:
    vpn:
      enabled: true # in case we ever need it
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "32400,3000,8888,3001,3002"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      volumeMounts:
      - mountPath: /shared
        name: shared
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /web/index.html
          port: 32400
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /web/index.html
          port: 32400
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /web/index.html
          port: 32400
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10          

jellyfin: &app_jellyfin
  hostname: elfhosted
  image:
    repository: ghcr.io/elfhosted/jellyfin
    tag: 10.10.7@sha256:71679560121bfe361e924d06af9b7c958b58410f42f7f278c98252387d35aa80
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  enabled: false
  podLabels:
    app.elfhosted.com/name: jellyfin
  podAnnotations:
    elfbot.elfhosted.com/name: "Jellyfin"
    elfbot.elfhosted.com/category: Consume Media
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jellyfin.png"  
    kubernetes.io/egress-bandwidth: "150M" # tested with _kilos in Discord on a 97Mbit remux
  priorityClassName: tenant-streaming
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    privileged: true
  podSecurityContext:
    fsGroup: 568
    runAsUser: 568
    runAsGroup: 568    
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
    supplementalGroups:
    - 993
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-jellyfin,jellyfin-env,elfbot-zurg,elfbot-decypharr,elfbot-debridav" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence: &app_jellyfin_persistence
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: jellyfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: "/config/log/"
      subPath: jellyfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs             
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: jellyfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-1g  
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-jellyfin
          optional: true
    render-device: *streamer_render_device
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
  initContainers:
    restart-with-zurg:
      image: ghcr.io/elfhosted/zurg-rc:2025.07.29.0047-nightly@sha256:1a42b75a1758065b7250033758a4c957dece6510d5345e3a21255adc6ce805f7
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when zurg is updated"
    restart-with-decypharr:
      image: ghcr.io/elfhosted/decypharr:v1.0.5@sha256:b0d539fe2217cce88979e65f6982afd872579a5fbc72140c06c36bfe0e2fdf3d
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when decypharr is updated"
    restart-with-debridav:
      image: ghcr.io/elfhosted/debridav:0.10.1@sha256:67748eff91c1c318827284bb31a9f39c2ce10b22e29e58ec4f65659152fd8cfe
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when debridav is updated"   
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: jellyfin
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: false # necessary for probes
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 8096
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 8096
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 8096
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
  resources:
    requests:
      cpu: "50m"
      memory: 1Gi
    limits:
      cpu: 2
      memory: 4Gi
  envFrom:
  - configMapRef:
      name: jellyfin-env
  - configMapRef:
      name: elfbot-jellyfin
      optional: true          
  additionalContainers:
    speedtest:
      image: openspeedtest/latest:latest@sha256:1745e913f596fe98882b286a67751efdae74774e9caa742a4934bb056e8748d2
      imagePullPolicy: IfNotPresent
      securityContext: *speedtest_securitycontext
    jellyfixer:
      image: quay.io/xsteadfastx/jellyfixer:latest
      env:
        JELLYFIXER_INTERNAL_URL: http://jellyfin:8096
        JELLYFIXER_EXTERNAL_URL: https://{{ .Release.Name }}-jellyfin.elfhosted.com
      

jellyfinranger:
  <<: *app_jellyfin
  podLabels:
    app.elfhosted.com/name: jellyfin
  podAnnotations: 
    <<: *ranger_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jellyfin.png"
    elfbot.elfhosted.com/name: "Jellyfin"
    elfbot.elfhosted.com/category: Consume Media   
  enabled: false
  automountServiceAccountToken: false
  resources: *ranger_streamer_resources
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-jellyfin,elfbot-all"
  persistence:
    <<: *app_jellyfin_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: jellyfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

emby: &app_emby
  hostname: elfhosted
  image:
    registry: ghcr.io
    repository: elfhosted/emby
    tag: 4.9.1.12@sha256:aabb6aa43bc0b051a3c667aa8f167fc8f35c4852990c595795b55a92f3a02cf8
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  enabled: false
  priorityClassName: tenant-streaming
  podLabels:
    app.elfhosted.com/name: emby
  podAnnotations:
    elfbot.elfhosted.com/name: "Emby"
    elfbot.elfhosted.com/category: Consume Media
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/emby.png"  
    kubernetes.io/egress-bandwidth: "150M" # tested with _kilos in Discord on a 97Mbit remux
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem:
    privileged: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
    supplementalGroups:
    - 993
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-emby,emby-env,elfbot-zurg,elfbot-decypharr,elfbot-debridav" # Reload the deployment every time the rclones change
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  envFrom:
  - configMapRef:
      name: emby-env
  - configMapRef:
      name: elfbot-emby
      optional: true      
  persistence: &app_emby_persistence
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: emby
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: "/config/log/"
      subPath: emby
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs                
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: emby
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-1g  
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-emby
          optional: true
    render-device: *streamer_render_device
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
  initContainers:
    restart-with-zurg:
      image: ghcr.io/elfhosted/zurg-rc:2025.07.29.0047-nightly@sha256:1a42b75a1758065b7250033758a4c957dece6510d5345e3a21255adc6ce805f7
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when zurg is updated"
    restart-with-decypharr:
      image: ghcr.io/elfhosted/decypharr:v1.0.5@sha256:b0d539fe2217cce88979e65f6982afd872579a5fbc72140c06c36bfe0e2fdf3d
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when decypharr is updated"
    restart-with-debridav:
      image: ghcr.io/elfhosted/debridav:0.10.1@sha256:67748eff91c1c318827284bb31a9f39c2ce10b22e29e58ec4f65659152fd8cfe
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when debridav is updated"   
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: emby
      - mountPath: /tmp
        name: tmp
  additionalContainers:
    speedtest:
      image: openspeedtest/latest:latest@sha256:1745e913f596fe98882b286a67751efdae74774e9caa742a4934bb056e8748d2
      imagePullPolicy: IfNotPresent
      securityContext: *speedtest_securitycontext
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: false # necessary for probes
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /
          port: 8096
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /
          port: 8096
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /
          port: 8096
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
  resources:
    requests:
      cpu: "50m"
      memory: 1Gi
    limits:
      cpu: 2
      memory: 4Gi

embyranger:
  <<: *app_emby
  podLabels:
    app.elfhosted.com/name: emby
  podAnnotations: 
    <<: *ranger_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/emby.png"
    elfbot.elfhosted.com/name: "Emby"
    elfbot.elfhosted.com/category: Consume Media   
  enabled: false
  automountServiceAccountToken: false
  resources: *ranger_streamer_resources
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-emby,elfbot-all"
  persistence:
    <<: *app_emby_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: emby
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

homer:
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    runAsNonRoot: false
    runAsUser: 568
    runAsGroup: 568
  podLabels:
      app.elfhosted.com/name: homer    
  podAnnotations:
    elfbot.elfhosted.com/name: "Homer"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/homer.png"
    elfbot.elfhosted.com/category: Tools
  podSecurityContext:
    runAsNonRoot: false
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "Always"
  automountServiceAccountToken: false
  image:
    repository: ghcr.io/elfhosted/tooling
    tag: focal-20230605@sha256:6088a1e9fc0ce83aec9910af0899661c23b5f2025428d7da631b9b9390241b6c
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
  podLabels:
    app.elfhosted.com/role: nodefinder # let this be an anchor for replicationdestinations
  persistence:
    <<: *storagemounts
    logs:
      enabled: true
      type: custom
      mountPath: /logs
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    config:
      enabled: true
      type: custom
      mountPath: /config
      volumeSpec:
        persistentVolumeClaim:
          claimName: config          
    backup:
      enabled: true
      type: custom
      mountPath: /backup
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup
    config-yml:
      enabled: "true"
      subPath: "config.yml"
      type: "custom"
      volumeSpec:
        configMap:
          name: homer-config
    custom-css:
      enabled: "true"
      subPath: "custom-css"
      type: "custom"
      volumeSpec:
        configMap:
          name: homer-config
    gatus-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: gatus-config
    disk-usage:
      enabled: "true"
      mountPath: "/usr/local/bin/disk_usage.sh"
      subPath: "disk_usage.sh"
      type: "custom"
      volumeSpec:
        configMap:
          name: homer-config
    message:
      enabled: true
      type: emptyDir
      mountPath: /www/assets/message
  command:
  - /bin/bash
  - /usr/local/bin/disk_usage.sh
  additionalContainers:
    ui:
      image: ghcr.io/elfhosted/homer:v25.05.2@sha256:af039caf8ba491cc10ce243220a2aa4e14134dd208ce826279373fff74448768
      imagePullPolicy: IfNotPresent
      volumeMounts:
      - mountPath: /www/assets/config.yml
        name: config-yml
        subPath: "config.yml"
      - mountPath: /www/assets/custom.css
        name: custom-css
        subPath: "custom.css"
      - mountPath: /www/assets/message
        name: message
      - mountPath: /www/assets/backgrounds
        name: config
        subPath: homer/backgrounds
        readOnly: true
      resources: *default_resources
      securityContext: *default_securitycontext
  configmap:
    config:
      # -- Store homer configuration as a ConfigMap, but don't specify any config, since we'll supply our own
      enabled: false
  controller:
    replicas: 1
    strategy: RollingUpdate
    rollingUpdate:
      unavailable: 1
    annotations:
      configmap.reloader.stakater.com/reload: "homer-config, elfbot-homer" # Reload the deployment every time the yaml config changes
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 200m
      memory: 1Gi

traefikforwardauth:
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  whitelist: admin@elfhosted.com
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  controller:
    replicas: 1
    annotations:
      configmap.reloader.stakater.com/reload: traefik-forward-auth-config
    strategy: RollingUpdate
  image:
    repository: ghcr.io/elfhosted/traefik-forward-auth
    pullPolicy: IfNotPresent
    tag: 3.1.0@sha256:19cd990fae90c544100676bc049f944becc8c454639e57d20f6f48e27de90776

  middleware:
    # middleware.enabled -- Enable to deploy a preconfigured middleware
    enabled: false

  envFrom:
  - configMapRef:
      name: traefik-forward-auth-config

  ingress:
    main:
      enabled: false

  service:
    main:
      enabled: true # necessary for probes

  resources:
    requests:
      cpu: 0m
      memory: 6Mi
    limits:
      cpu: 1
      memory: 32Mi

gatus:
  image:
    repository: ghcr.io/elfhosted/gatus
    tag: 5.20.0@sha256:1115118413eec3db379d4993c67e37ed92b19b7b111185695e5ea5eda76d3332
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 20Mi
    limits:
      cpu: 1
      memory: 128Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  controller:
    # strategy: RollingUpdate
    annotations:
      configmap.reloader.stakater.com/reload: "gatus-config"
  env:
    GATUS_CONFIG_PATH: /config/config.yaml
    SMTP_FROM: 'health@elfhosted.com'
    SMTP_PORT: 587
  persistence:
    gatus-config:
      enabled: "true"
      mountPath: /config
      type: "custom"
      volumeSpec:
        configMap:
          name: gatus-config
    config:
      enabled: true
      type: custom
      mountPath: /data/
      subPath: gatus
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
  envFrom:
  - secretRef:
      name: gatus-smtp-config
  configmap:
    config:
      # -- Store homer configuration as a ConfigMap, but don't specify any config, since we'll supply our own
      enabled: false

gotify:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/gotify
    tag: 2.5.0@sha256:f5c89bb3ccbf857bca816e4550b46c442cfb6c0eae0f081975ba5c5099779c3f
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: gotify  
  podAnnotations:
    elfbot.elfhosted.com/name: "Gotify"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/gotify.png"  
    elfbot.elfhosted.com/category: Tools     
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-gotify"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  env:
    GOTIFY_SERVER_PORT: 8080
  resources:
    requests:
      cpu: 0m
      memory: 32Mi
    limits:
      cpu: 1
      memory: 64Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /app/data/
      subPath: gotify
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-gotify
          optional: true
    tmp: *tmp # Avoids issues with readOnlyRootFilesystem
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: gotify
      - mountPath: /tmp
        name: tmp

flaresolverr: &app_flaresolverr
  enabled: false
  podLabels:
    app.elfhosted.com/name: flaresolverr
  podAnnotations:
    elfbot.elfhosted.com/name: "Flaresolverr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/flaresolverr.png"      
  image:
    registry: ghcr.io
    repository: elfhosted/flaresolverr
    tag: 3.3.25@sha256:542df3605a7e999969d61bdbbcf5d5a25ea53f3b9f23b38d93253f8fb3e679a3
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # makes node unhappy
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-flaresolverr"
  persistence:
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory  
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    # runAsUser: 1000
    # runAsGroup: 1000
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 600m
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8191
  initContainers:
    setup-warp: *setup_warp     
  addons:
    vpn:
      enabled: false # in case we ever need it
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "8191"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      volumeMounts:
      - mountPath: /shared
        name: shared     

byparr:
  enabled: false
  podLabels:
    app.elfhosted.com/name: byparr
  podAnnotations:
    elfbot.elfhosted.com/name: "Byparr"
    elfbot.elfhosted.com/icon: "fas fa-cloud"
    elfbot.elfhosted.com/category: Download Media
  image:
    registry: ghcr.io
    repository: elfhosted/byparr
    tag: v1.2.1@sha256:38f47cca6a8300afbb0f704e7574188e8b836b59a9359ecb9820c4b2366954e1
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # makes node unhappy
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-byparr"
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 600m
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8191          

tunarr:
  enabled: false
  image:
    registry: ghcr.io
    repository: chrisbenincasa/tunarr
    tag: 0.20.6-vaapi
  podLabels:
      app.elfhosted.com/name: tunarr    
  podAnnotations:
    elfbot.elfhosted.com/name: "Tunarr"
    elfbot.elfhosted.com/icon: "fas fa-tv"  
    kubernetes.io/egress-bandwidth: "150M"      
    elfbot.elfhosted.com/category: Consume Media      
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    privileged: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-tunarr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
    supplementalGroups:
    - 993
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 256Mi
    limits:
      cpu: 1
      memory: 2Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /root/.local
      subPath: tunarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-tunarr
          optional: true
    render-device: *streamer_render_device
    media: # in case users use /tmp
      enabled: true
      mountPath: /streams
      type: emptyDir
      sizeLimit: 50Gi
    cache: # in case users use /tmp
      enabled: true
      mountPath: /root/.cache/pkg
      type: emptyDir
      sizeLimit: 10Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: tunarr
      - mountPath: /tmp
        name: tmp

ersatztv:
  enabled: false
  image:
    registry: docker.io
    repository: jasongdove/ersatztv
    tag: develop-vaapi@sha256:04bfca875a7da7c7ba15bca1e9c79a3b6b26d4ead20a5d0ae22ad037700b03d5
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: ersatztv  
  podAnnotations:
    elfbot.elfhosted.com/name: "ErsatzTV"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/ersatztv.png"   
    elfbot.elfhosted.com/category: Consume Media     
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    privileged: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-erzatztv"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
    supplementalGroups:
    - 993
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 256Mi
    limits:
      cpu: 1
      memory: 2Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8409
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /root/.local/share/ersatztv
      subPath: ersatztv
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    transcode:
      enabled: true
      type: custom
      mountPath: /root/.local/share/etv-transcode
      volumeSpec: *volumespec_ephemeral_volume_50g          
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-tunarr
          optional: true
    render-device: *streamer_render_device
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: ersatztv
      - mountPath: /tmp
        name: tmp

threadfin:
  enabled: false
  image:
    registry: ghcr.io
    repository: elfhosted/threadfin
    tag: 1.2.35@sha256:0e056fd818094e1cc07cc9d64065e85fb6a40a06a6f7eba60cab8cc3f1785b34
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: threadfin  
  podAnnotations:
    elfbot.elfhosted.com/name: "Threadfin"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/threadfin.png"    
    elfbot.elfhosted.com/category: Consume Media    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-threadfin"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 256Mi
    limits:
      cpu: 1
      memory: 2Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 34400
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /home/threadfin/conf/
      subPath: threadfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-tunarr
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: threadfin
      - mountPath: /tmp
        name: tmp

thelounge:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/thelounge
    tag: "4.4.3@sha256:74ae8d9fc36d5a8396bb70cfaa58d222730fa69d2f71c3e2ec3ae010f2a0b264"
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: thelounge  
  podAnnotations:
    elfbot.elfhosted.com/name: "TheLounge"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/thelounge.png"        
    elfbot.elfhosted.com/category: Tools
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-thelounge"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # doesn't work because the node modules in /app try to create files
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"

  env:
    TZ: UTC
    THELOUNGE_HOME: /config/thelounge # avoids attempts to chown /config
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 40Mi
    limits:
      cpu: 100m
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9000
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: thelounge
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-thelounge
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: thelounge
      - mountPath: /tmp
        name: tmp
    create-user:
      image: ghcr.io/elfhosted/thelounge:4.4.3@sha256:74ae8d9fc36d5a8396bb70cfaa58d222730fa69d2f71c3e2ec3ae010f2a0b264
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e


        # If we don't already have a config, create one
        if [ ! -f /config/thelounge/config.json ];
        then
          mkdir -p /config/thelounge
          cp /config-bootstrap/* /config/thelounge/ -R
        fi

        # If we don't already have a user, create one
        if [ ! -f /config/thelounge/users/${USERNAME}.json ];
        then
          thelounge add ${USERNAME} --password ${PASSWORD}
        fi
      volumeMounts:
      - mountPath: /config
        subPath: thelounge
        name: config
      env:
      - name: THELOUNGE_HOME
        value: /config/thelounge # avoids attempts to chown /config
      - name: USERNAME
        valueFrom:
          configMapKeyRef:
            name: elfhosted-user-config
            key: USERNAME
      - name: PASSWORD
        value: ireadthedocs
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true

symlinkcleaner:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/symlink-cleaner
    tag: v1.4.7@sha256:48583e349c118af8e9ba607241d7495ade44ffad3a14d771653f7aa739c0a632
  imagePullSecrets:
  - name: ghcr-io-elfhosted
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: symlinkcleaner  
  podAnnotations:
    elfbot.elfhosted.com/name: "Symlink Cleaner"
    elfbot.elfhosted.com/icon: "fas fa-broom" 
    elfbot.elfhosted.com/category: Tools       
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-symlink-cleaner,symlink-cleaner-example-config"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # doesn't work because the node modules in /app try to create files
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 40Mi
    limits:
      cpu: 100m
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5000
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 5000
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 5000
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 45
        httpGet:
          path: /health
          port: 5000
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 5
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /app/config
      subPath: symlink-cleaner
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /app/logs
      subPath: symlink-cleaner
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs          
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-symlink-cleaner
          optional: true          
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: symlink-cleaner-example-config          
  envFrom:
  - configMapRef:
      name: symlink-cleaner-env
  - configMapRef:
      name: elfbot-symlink-cleaner
      optional: true    
  initContainers:  
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: symlink-cleaner
      - mountPath: /tmp
        name: tmp      
    copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e
        # If we don't already have an example config, create one
        if [ ! -f /config/config.json ];
        then
          cp /bootstrap/config.json /config/
        fi
      volumeMounts:
      - mountPath: /config/
        name: config
        subPath: symlink-cleaner
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext: *default_securitycontext  

discovarr:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/discovarr
    tag: v1.2.0@sha256:fd33f143f23635460f4ebdad07ba665bd7eb67e27ea7a3189db1d148dd5169e8
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podLabels:
    app.elfhosted.com/name: discovarr
  podAnnotations:
    elfbot.elfhosted.com/name: "Discovarr"
    elfbot.elfhosted.com/icon: "fas fa-sitemap"  
    elfbot.elfhosted.com/category: Manage Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-discovarr,discovarr-config"
  # Always prefer to cohabit with zurg
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: discovarr-env
  - configMapRef:
      name: elfbot-discovarr
      optional: true  
  persistence:
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: discovarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-discovarr
          optional: true
    tmp: *tmp
    backup: *backup
    cache:
      mountPath: /cache
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi 
    static:
      mountPath: /app/server/static
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi          
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: discovarr
      - mountPath: /tmp
        name: tmp
    setup:
      image:  ghcr.io/elfhosted/discovarr:v1.2.0@sha256:fd33f143f23635460f4ebdad07ba665bd7eb67e27ea7a3189db1d148dd5169e8
      command:
      - /bin/sh
      - -c
      - |
        set -x
        set -e

        # Directory where your built frontend assets are located (copied from client/dist)
        # This path is inside the Docker container.
        STATIC_ASSETS_DIR="/static"

        cp /app/server/static/* /static/ -rf
        echo "INFO: Replacing placeholder '${PLACEHOLDER}' with '${VITE_DISCOVARR_URL}' in JS and HTML files..."

        # Find all .js and .html files in the static assets directory and its subdirectories
        # and replace the placeholder.
        # Using '#' as a delimiter for sed to avoid issues with slashes ('/') in the URL.
        # The -print0 and xargs -0 pattern handles filenames with spaces or special characters.
        find "${STATIC_ASSETS_DIR}" -type f \( -name "*.js" -o -name "*.html" \) -print0 | \
          xargs -0 sed -i "s#__API_ENDPOINT__#${VITE_DISCOVARR_URL}#g"
      volumeMounts:
      - mountPath: /static
        name: static
      envFrom:
      - configMapRef:
          name: discovarr-env
      - configMapRef:
          name: elfbot-discovarr
          optional: true          
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  resources:
    requests:
      cpu: 0m
      memory: 175Mi
    limits:
      cpu: 500m
      memory: 2Gi

overseerr:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/overseerr
    tag: 1.34.0@sha256:d9cfaf805e8512684cec4b5c897e372d898eeff522cef0801f3245cb3d00caf6
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podLabels:
    app.elfhosted.com/name: overseerr
  podAnnotations:
    elfbot.elfhosted.com/name: "Overseerr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/overseerr.png"      
    elfbot.elfhosted.com/category: Manage Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-overseerr,overseerr-config"
  # Always prefer to cohabit with zurg
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: overseerr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-overseerr
          optional: true
    tmp: *tmp
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
    overseerr-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: overseerr-config
          optional: true 
    run:
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi                   
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: overseerr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        # run the setup script from the configmap, so that we can make templated changes
        bash /bootstrap/setup.sh
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: overseerr
      - name: overseerr-config
        mountPath: "/bootstrap/"
    # We do this so that we can override the /app/jellyseer/public path with our own, allowing the user to customize the branding
    copy-branding:
      image: ghcr.io/elfhosted/overseerr:1.34.0@sha256:d9cfaf805e8512684cec4b5c897e372d898eeff522cef0801f3245cb3d00caf6
      command:
        - /bin/bash
        - -c
        - |
          mkdir -p /config/branding
          cp --no-clobber -rf /app/overseerr/public/logo_* /config/branding
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: overseerr
      resources: *default_resources
      securityContext: *default_securitycontext
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5055
  resources:
    requests:
      cpu: 0m
      memory: 175Mi
    limits:
      cpu: 2
      memory: 2Gi
  additionalContainers:
    branding:
      image: nginxinc/nginx-unprivileged
      volumeMounts:
      - mountPath: /usr/share/nginx/html
        name: config
        subPath: overseerr/branding
        readOnly: true
      - mountPath: /tmp
        name: tmp
      - mountPath: /run
        name: run
      resources: *default_resources
      securityContext: *default_securitycontext

jellyseerr:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/jellyseerr
    tag: 2.7.2@sha256:8a50b2aa7b77d92efa6bcb177a7b093d00ae52fddf8801ac1bc094c48f8d2801
  priorityClassName: tenant-normal
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podLabels:
    app.elfhosted.com/name: jellyseerr
  podAnnotations:
    elfbot.elfhosted.com/name: "Jellyseerr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jellyseerr.png"
    elfbot.elfhosted.com/category: Manage Media      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-jellyseerr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: jellyseerr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-jellyseerr
          optional: true
    tmp: *tmp
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
    jellyseerr-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: jellyseerr-config
          optional: true
    run:
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi            
  envFrom:
  - configMapRef:
      name: jellyseerr-env
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: jellyseerr
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        # run the setup script from the configmap, so that we can make templated changes
        bash /bootstrap/setup.sh
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: jellyseerr
      - name: jellyseerr-config
        mountPath: "/bootstrap/"        
    # We do this so that we can override the /app/jellyseer/public path with our own, allowing the user to customize the branding
    copy-branding:
      image: ghcr.io/elfhosted/jellyseerr:2.7.2@sha256:8a50b2aa7b77d92efa6bcb177a7b093d00ae52fddf8801ac1bc094c48f8d2801
      command:
        - /bin/ash
        - -c
        - |
          mkdir -p /config/branding
          cp --no-clobber -rf /app/public/logo_* /config/branding/
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: jellyseerr
      resources: *default_resources
      securityContext: *default_securitycontext
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5055
  resources:
    requests:
      cpu: 0m
      memory: 160Mi
    limits:
      cpu: 2
      memory: 1Gi
  additionalContainers:
    branding:
      image: nginxinc/nginx-unprivileged
      volumeMounts:
      - mountPath: /usr/share/nginx/html
        name: config
        subPath: jellyseerr/branding
        readOnly: true
      - mountPath: /tmp
        name: tmp
      - mountPath: /run
        name: run
      resources: *default_resources
      securityContext: *default_securitycontext

jellystat:
  enabled: false
  podLabels:
    app.elfhosted.com/name: jellystat
  podAnnotations:
    elfbot.elfhosted.com/name: "Jellystat"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jellystat.png"  
    elfbot.elfhosted.com/category: Manage Media    
  image:
    repository: ghcr.io/elfhosted/jellystat
    tag: 1.1.6@sha256:39bb3980570b6dd56fac1becbb52cde40f821d6ac73eaef97dd9c3d9ec9d97bd
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-jellystat,jellystat-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work with ilikedanger currently
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: jellystat-env
  - configMapRef:
      name: elfbot-jellystat
      optional: true
  resources:
    requests:
      cpu: 0m
      memory: 20Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3000
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: jellystat/config
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    backup:
      enabled: true
      type: custom
      mountPath: /app/backup-data
      subPath: jellystat
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup          
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-jellystat
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: jellystat
      - mountPath: /tmp
        name: tmp
    setup-postgres:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        mkdir -p /config/database
        chown elfie:elfie /config/database -R

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: jellystat
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault    
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: jellystat
        - name: POSTGRES_DB
          value: jellystat
        - name: POSTGRES_USER
          value: jellystat
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: jellystat/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 1Gi

booklore:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/booklore
    tag: v0.35.0@sha256:92d8d481557a649f99490c6195756e98dc01718b06ce3571e93544e691cd99bc
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: booklore  
  podAnnotations:
    elfbot.elfhosted.com/name: "Booklore"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/booklore.png"     
    elfbot.elfhosted.com/category: Consume Media   
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-booklore,booklore-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    allowPrivilegeEscalation: false
    runAsNonRoot: false # because we need the permission-fixer to run as root
    capabilities:
      drop:
      - ALL        
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: booklore-env
  - configMapRef:
      name: elfbot-booklore
      optional: true
  resources:
    requests:
      cpu: 0m
      memory: 20Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 6060    
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /app/data
      subPath: booklore
      volumeSpec:
        persistentVolumeClaim:
          claimName: config        
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-booklore
          optional: true
  command: 
  - java 
  - -jar 
  - /app/app.jar     
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: booklore
      - mountPath: /tmp
        name: tmp
    setup-mariadb:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        mkdir -p /config/database
        chown elfie:elfie /config/database -R

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: booklore
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault   
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # There are symlinks pre-prepared for these
        mkdir -p /config/bookdrop

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: booklore
      resources: *default_resources
      securityContext: *default_securitycontext                     
  additionalContainers:
    frontend:
      image: ghcr.io/elfhosted/booklore:v0.35.0@sha256:92d8d481557a649f99490c6195756e98dc01718b06ce3571e93544e691cd99bc
      command: 
      - /usr/sbin/nginx 
      - -g 
      - "daemon off;"
      securityContext:
        readOnlyRootFilesystem: false
        runAsUser: 0 # nginx insists on running as root
    database:
      image: mariadb:11 
      env:
        - name: MYSQL_ROOT_PASSWORD
          value: booklore
        - name: MYSQL_DATABASE
          value: booklore
        - name: MYSQL_USER
          value: booklore
        - name: MYSQL_PASSWORD
          value: booklore
      volumeMounts:
      - mountPath: /var/lib/mysql
        name: config
        subPath: booklore/database
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 1Gi

peertube:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/peertube-cli
    tag: v7.2.3@sha256:97865b5d959151cd05d37b3b337a3b946fc4c334b9d831c45d2bc4e7c870bbae
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: peertube  
  podAnnotations:
    elfbot.elfhosted.com/name: "PeerTube"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/peertube.png"   
    elfbot.elfhosted.com/category: Tools     
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-peertube,peertube-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    privileged: true # needed for transcoding
    runAsNonRoot: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    supplementalGroups:
    - 993      
    allowPrivilegeEscalation: false
    runAsNonRoot: false
    capabilities:
      drop:
      - ALL        
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 20Mi
    # no limits (this is only usable with a nazgul)
    # limits:
    #   cpu: 1
    #   memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9000
    probes:
      liveness:
        custom: true
        enabled: true
        spec:
          failureThreshold: 5
          httpGet:
            path: /api/v1/ping
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 10
      readiness:
        custom: true
        enabled: true
        spec:
          failureThreshold: 5
          httpGet:
            path: /api/v1/ping
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 10
      startup:
        custom: true
        enabled: true
        spec:
          failureThreshold: 5
          httpGet:
            path: /api/v1/ping
            port: http
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 10          
  persistence:
    <<: *storagemounts
    logs:
      enabled: true
      type: custom
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    config:
      enabled: true
      type: custom
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
      mountPath: /home/elfie
      subPath: peertube/cli
    # the idea is to use this for temporary uploads
    tmp:
      enabled: true
      type: custom
      mountPath: /tmp
      volumeSpec: *volumespec_ephemeral_volume_500g      
    backup:
      enabled: true
      type: custom
      volumeSpec:
        persistentVolumeClaim:
          claimName: backup          
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-peertube
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory
    data-tmp:
      enabled: "true"
      type: emptyDir      
    render-device: *streamer_render_device
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: peertube
      - mountPath: /tmp
        name: tmp
    setup-postgres:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        mkdir -p /config/database
        chown elfie:elfie /config/database -R

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: peertube
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault    
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: peertube
        - name: POSTGRES_DB
          value: peertube
        - name: POSTGRES_USER
          value: peertube
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: peertube/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 1Gi
    redis:
      image: docker.io/redis:7.4-alpine@sha256:bb186d083732f669da90be8b0f975a37812b15e913465bb14d845db72a4e3e08
      resources:
        requests:
          cpu: 15m
          memory: 200Mi
        limits:
          cpu: 100m
          memory: 4Gi
      volumeMounts:
      - mountPath: /data
        name: config
        subPath: peertube/redis
    ui:
      image: ghcr.io/elfhosted/peertube-nonroot:v7.2.3@sha256:2dc6861559d4b5587e143e685b5390f31fb0818ad74036b226183b338145ef2f
      volumeMounts:
      - mountPath: /data
        name: config
        subPath: peertube/app
      - mountPath: /data/logs
        name: logs
        subPath: peertube
      - mountPath: /data/tmp
        name: data-tmp
      - mountPath: /home/peertube/.cache
        name: tmp   
      - mountPath: /dev/dri
        name: render-device
      envFrom:
      - configMapRef:
          name: peertube-env
      - configMapRef:
          name: elfbot-peertube
          optional: true        
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true
        privileged: true # needed for transcoding
        runAsNonRoot: true
        
audiobookshelf:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/audiobookshelf
    tag: v2.26.3@sha256:5d55bc91288d7deb05d32e98b19be020c586fb872801680e7e2d220bd1a7b66d
  priorityClassName: tenant-streaming
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podLabels:
    app.elfhosted.com/name: audiobookshelf
  podAnnotations:
    elfbot.elfhosted.com/name: "Audiobookshelf"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/audiobookshelf.png"    
    elfbot.elfhosted.com/category: Consume Media  
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-audiobookshelf,elfbot-all"
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: audiobookshelf
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    # never used, just satisfies startup scripts
    metadata:
      enabled: true
      type: emptyDir
      mountPath: /metadata
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-audiobookshelf
          optional: true
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
  env:
    METADATA_PATH: /config/metadata
    SOURCE: ElfHosted
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: audiobookshelf
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 1Gi

storyteller:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/storyteller
    tag: v1.4.0-ctc.7@sha256:1081edd3ec29b3ef32df8887e5e388f7686ce288bde4c7b9cff8e448e12a26ae
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podLabels:
      app.elfhosted.com/name: storyteller    
  podAnnotations:
    elfbot.elfhosted.com/name: "Storyteller"
    elfbot.elfhosted.com/icon: "fas fa-book-open"        
    elfbot.elfhosted.com/category: Consume Media
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-storyteller,elfbot-all"
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /data/
      subPath: storyteller
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    # never used, just satisfies startup scripts
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-storyteller
          optional: true
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
    cache: 
      enabled: true
      type: emptyDir
      mountPath: /app/.next/standalone/web/.next/cache         
    whisper-builds:
      enabled: true
      type: emptyDir
      mountPath: /app/.next/standalone/web/whisper-builds
    home-elfie:
      enabled: true
      type: emptyDir
      mountPath: /home/elfie
  envFrom:
  - configMapRef:
      name: storyteller-env
  - secretRef:
      name: storyteller-env      
  - configMapRef:
      name: elfbot-storyteller
      optional: true          
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: storyteller
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8001
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 12Gi


audiobookrequest:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/audiobookrequest
    tag: 1.4.9@sha256:521fdad8e952c386c05d061330976bd631cdcdc02946cc254c753d20445686e6
  priorityClassName: tenant-streaming
  podLabels:
      app.elfhosted.com/name: audiobookrequest  
  podAnnotations:
    elfbot.elfhosted.com/name: "AudioBookRequest"
    elfbot.elfhosted.com/icon: "fas fa-book"    
    elfbot.elfhosted.com/category: Manage Downloads    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-audiobookrequest,elfbot-all"
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: audiobookrequest
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-audiobookrequest
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: audiobookrequest
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 1Gi

audiobookbayautomated:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/audiobookbay-automated
    tag: rolling@sha256:1c44d86d4f1b6bc93368bc3f5132ea1a061df2a6db8b013ba6cb4ab81377cd6b
  podLabels:
      app.elfhosted.com/name: audiobookbay-automated    
  podAnnotations:
    elfbot.elfhosted.com/name: "AudioBookBay Automated"
    elfbot.elfhosted.com/icon: "fas fa-book"       
    elfbot.elfhosted.com/category: Manage Downloads
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-audiobookbay-automated,audiobookbay-automated-env"
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: audiobookbay-automated
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-audiobookbay-automated
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: audiobookbay-automated
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5078
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 1Gi      
  envFrom:
  - configMapRef:
      name: audiobookbay-automated-env      

openbooks:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/openbooks
    tag: 4.5.0@sha256:c17d8e86d55e35cd1edb20fe1e1ff95a8e93cbef4c571ead2bfeb07276845477
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: openbooks  
  podAnnotations:
    elfbot.elfhosted.com/name: "OpenBooks"
    elfbot.elfhosted.com/icon: "fas fa-book"   
    elfbot.elfhosted.com/category: Manage Downloads     
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  persistence:
    <<: *storagemounts
  command:
  - /bin/bash
  - -c
  - |
    set -x
    set -e
    sleep 5s
    USER=$(tr -dc A-Za-z0-9 </dev/urandom | head -c 13 ; echo '')
    ./openbooks server \
      --dir ${DATA_DIR-/tmp} \
      --port 8000 \
      --name $USER \
      --tls=false \
      --persist \
      --server irc.irchighway.net:6661 \
      --no-browser-downloads \
      --debug
  envFrom:
  - configMapRef:
      name: elfbot-openbooks
      optional: true
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-openbooks"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 1Gi

vaultwarden:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/vaultwarden
    tag: 1.34.3@sha256:2a1a0bdb3130eb92bb6eca60403ab7773f46db6ae0b9e80fb3bd031f69ffc205
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: vaultwarden  
  podAnnotations:
    elfbot.elfhosted.com/name: "VaultWarden"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/vaultwarden.png"  
    elfbot.elfhosted.com/category: Tools      
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-vaultwarden"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: elfbot-vaultwarden
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /data
      subPath: vaultwarden
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-vaultwarden
          optional: true
    tmp: *tmp
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: vaultwarden
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  resources:
    requests:
      cpu: 0m
      memory: 16Mi
    limits:
      cpu: 1
      memory: 1Gi


notifiarr:
  enabled: false
  hostname: elfhosted
  image:
    repository: ghcr.io/elfhosted/notifiarr
    tag: 0.8.3@sha256:16d9f57524a249fd6181b9282a0c2c66e24caf417b692199d4dec2681784fc4c
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: notifiarr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Notifiarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/notifiarr.png"      
    elfbot.elfhosted.com/category: Tools  
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # doesn't work because the node modules in /app try to create files
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-notifiarr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"

  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 16Mi
    limits:
      cpu: 2
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5454
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: notifiarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: notifiarr-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-notifiarr
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: notifiarr
      - mountPath: /tmp
        name: tmp
    copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # If we don't already have an example config, create one
        if [ ! -f /config/notifiarr.conf ];
        then
          cp /bootstrap/notifiarr.conf /config/
        fi
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: notifiarr
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true

shoko:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/shokoserver
    tag: v5.1.0@sha256:a386f39bcfd7c1e8f9c38b4171c8e59162e3e1b2c579728465fd4ea52978a69e
  podLabels:
      app.elfhosted.com/name: shoko    
  podAnnotations:
    elfbot.elfhosted.com/name: "Shoko"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/shoko.png"  
    elfbot.elfhosted.com/category: Manage Media      
  env:
    PUID: 568
    PGID: 568
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-shoko"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # again, s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /home/shoko/.shoko/
      subPath: shoko
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-shoko
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: shoko
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8111
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

filebot:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/filebot-node
    tag: 0.4.8@sha256:2f35281e7f6d4a1566dfe6427dae83480c76d1cebe1e5d6d2379064db1846ba7
  podLabels:
      app.elfhosted.com/name: filebot    
  podAnnotations:
    elfbot.elfhosted.com/name: "FileBot"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/filebot.png"    
    elfbot.elfhosted.com/category: Tools    
  env:
    PUID: 568
    PGID: 568
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-filebot"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # again, s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /data
      subPath: filebot
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-filebot
          optional: true

    tmp: # to avoid errors about storing java prefs
      enabled: true
      type: emptyDir
      mountPath: /home/seedy
      sizeLimit: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: filebot
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5452
  resources:
    requests:
      cpu: 0m
      memory: 16Mi
    limits:
      cpu: 2
      memory: 1Gi

rpdb:
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: rpdb  
  podAnnotations:
    elfbot.elfhosted.com/name: "RPDB"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/rpdb.png"  
    elfbot.elfhosted.com/category: Manage Media      
  image:
    repository: ghcr.io/elfhosted/rpdb
    tag: 0.3.3@sha256:fc651aeb123bedbcb92eeda3227b51005540b3c350bf15640c7928f5e8fd1d4b
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,storage-changed,elfbot-rpdb"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /.config
      subPath: rpdb
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-rpdb
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: rpdb
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8750
  resources:
    requests:
      cpu: 0m
      memory: 40Mi
    limits:
      cpu: 1
      memory: 1Gi

kometa: &app_kometa
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: kometa  
  podAnnotations:
    elfbot.elfhosted.com/name: "Kometa"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/kometa.png"     
    elfbot.elfhosted.com/category: Manage Media   
  image:
    repository: ghcr.io/elfhosted/kometa
    tag: v2.2.0@sha256:d0d56d58de2ef623d7167e1dbf4901aa7bc2dc5ca4ec7206dbf1de5b2906d7d1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-kometa"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  envFrom:
  - configMapRef:
      name: elfbot-kometa
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: kometa
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs/
      subPath: kometa
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-kometa
          optional: true
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: kometa-config
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: kometa
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # If we don't already have an example config, create one
        if [ ! -f /config/config.yml ];
        then
          cp /bootstrap/config.yml /config/
        fi

        # Create directories we need by default
        mkdir -p /config/kometa/assets
        mkdir -p /config/kometa/logs
        mkdir -p /config/kometa/metadata
        mkdir -p /config/kometa/missing
        mkdir -p /config/kometa/overlays

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: kometa
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 4Gi

imagemaid:
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/imagemaid
    tag: v1.1.1@sha256:574796393e4366e19b602f530d61d22835b15d3367253c9225587a692e3e060b
  podLabels:
      app.elfhosted.com/name: imagemaid 
  podAnnotations:
    elfbot.elfhosted.com/name: "ImageMaid"
    elfbot.elfhosted.com/icon: "fas fa-image"      
    elfbot.elfhosted.com/category: Manage Media
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-imagemaid"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  envFrom:
  - configMapRef:
      name: imagemaid-env
  - configMapRef:
      name: elfbot-imagemaid
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-imagemaid
          optional: true
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: kometa-config
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: imagemaid
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 4Gi  

cinesync:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/cinesync
    tag: v3.0@sha256:26439a138e43b88bfff1c286a98f49cde90921254334133f3ce21de8688e3355
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false
  podLabels:
    app.elfhosted.com/name: cinesync
  podAnnotations:
    elfbot.elfhosted.com/name: "CineSync"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/cinesync.png"     
    elfbot.elfhosted.com/category: Manage Media 
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-cinesync,cinesync-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5173
  envFrom:
  - configMapRef:
      name: cinesync-env
  - secretRef:
      name: cinesync-env      
  - configMapRef:
      name: elfbot-cinesync
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /app/db
      subPath: cinesync
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-cinesync
          optional: true  
    logs:
      enabled: true
      type: custom
      mountPath: /app/logs
      subPath: cinesync
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    cache: # in case users use /tmp
      enabled: true
      mountPath: /cache
      type: emptyDir       
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: cinesync
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x

        # Create directory structure if it doesn't exist yet
        mkdir -p /storage/symlinks/movies
        mkdir -p /storage/symlinks/movies-4k
        mkdir -p /storage/symlinks/movies-anime
        mkdir -p /storage/symlinks/series
        mkdir -p /storage/symlinks/series-4k
        mkdir -p /storage/symlinks/series-anime
      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      resources: *default_resources
      securityContext: *default_securitycontext              
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 2Gi  

seerrbridge:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/seerrbridge
    tag: v0.7.2@sha256:4d13d92bb342d4fbdf68177e76aa14dca4841863465dd7875a82ba5c096fd44a
  podLabels:
      app.elfhosted.com/name: seerrbridge  
  podAnnotations:
    elfbot.elfhosted.com/name: "SeerrBridge"
    elfbot.elfhosted.com/icon: "fas fa-bridge"       
    elfbot.elfhosted.com/category: Manage Downloads
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # needs for temporary files I think
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-seerrbridge,seerrbridge-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    tmp: *tmp
    backup: *backup
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory      
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-seerrbridge
          optional: true                
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: seerrbridge
      volumeSpec:
        persistentVolumeClaim:
          claimName: config  
    logs:
      enabled: true
      type: custom
      mountPath: /app/logs
      subPath: seerrbridge
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs     
    npm: # for bridgeboard
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
    chromedriver: # needs to download chromedriver on start
      enabled: true
      mountPath: /app/seerr/chromedriver
      type: emptyDir
      sizeLimit: 1Gi           
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  envFrom:
  - configMapRef:
      name: seerrbridge-env
  - secretRef:
      name: seerrbridge-env      
  - configMapRef:
      name: elfbot-seerrbridge
      optional: true
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi  
  additionalContainers:
    bridgeboard:
      image: ghcr.io/elfhosted/seerrbridge-bridgeboard:v0.7.2@sha256:65956292cddb8ea3e57142c570cfb5de4bbb47fb62c8ba4adba7b4e293f16f59
      env:
        - name: SEERRBRIDGE_URL
          value: "http://localhost:8777"
        - name: SEERRBRIDGE_LOG_PATH
          value: /app/logs/seerbridge.log
      volumeMounts:
      - mountPath: /app/data
        name: config
        subPath: seerrbridge
      - mountPath: /app/logs
        name: logs
        subPath: seerrbridge
      - mountPath: /.npm
        name: npm
  initContainers:
    setup-warp: *setup_warp
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: seerrbridge
      - mountPath: /tmp
        name: tmp          
  addons:
    vpn:
      enabled: true # in case we ever need it
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "3001,8777,3777"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      volumeMounts:
      - mountPath: /shared
        name: shared               

listsync:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/listsync
    tag: 0.5.9@sha256:13a18a1f76947a4f2ca3d065d188ba570d0f633733abe1ea2cbce09664109f86
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # needs to create its own .venv
  podLabels:
    app.elfhosted.com/name: listsync
  podAnnotations:
    elfbot.elfhosted.com/name: "ListSync"
    elfbot.elfhosted.com/icon: "fas fa-list"      
    elfbot.elfhosted.com/category: Manage Downloads
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-listsync,listsync-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    backup: *backup
    tmp: *tmp     
    config:
      enabled: true
      type: custom
      mountPath: /usr/src/app/data
      subPath: listsync
      volumeSpec:
        persistentVolumeClaim:
          claimName: config  
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-listsync
          optional: true    
    logs:
      enabled: true
      type: custom
      mountPath: /logs
      subPath: listsync
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs                         
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  envFrom:
  - configMapRef:
      name: listsync-env
  - configMapRef:
      name: elfbot-listsync
      optional: true
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 2Gi  
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: listsync
      - mountPath: /tmp
        name: tmp  

plextraktsync:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/plextraktsync
    tag: 0.34.12@sha256:a022a8bb9342047095ddbed619ada69a6c8287a614e4ec4af1a0ece2dfbb52ea
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podLabels:
    app.elfhosted.com/name: plextraktsync
  podAnnotations:
    elfbot.elfhosted.com/name: "PlexTraktSync"
    elfbot.elfhosted.com/icon: "fas fa-sync"      
    elfbot.elfhosted.com/category: Manage Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-plextraktsync"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  envFrom:
  - configMapRef:
      name: elfbot-plextraktsync
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /home/elfie/.config/PlexTraktSync
      subPath: plextraktsync
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-plextraktsync
          optional: true
    state: # plextraktsync needs this
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
      mountPath: /home/elfie/.local/state
    cache: # plextraktsync needs this
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
      mountPath: /home/elfie/.cache      
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: plextraktsync
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 100m # no way this should be using so much resources
      memory: 1Gi

plexytrack:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/plexytrack
    tag: v0.3.4@sha256:906a69afe2eaedbbe79fda5f403f8d2029c83cc4d3193c44b61a106b75dc67de
  podLabels:
      app.elfhosted.com/name: plexytrack    
  podAnnotations:
    elfbot.elfhosted.com/name: "PlexyTrack"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/plexytrack.png"    
    elfbot.elfhosted.com/category: Manage Media    
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-plexytrack"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5030
  envFrom:
  - configMapRef:
      name: plexytrack-env 
  - configMapRef:
      name: elfbot-plexytrack
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: plexytrack
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-plexytrack
          optional: true    
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: plexytrack
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 100m # no way this should be using so much resources
      memory: 1Gi

letterboxdtraktsync:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/letterboxd-trakt-sync
    tag: v1.1.0@sha256:c0c8ebee2f51163f5cee41ec8d309ff45f2801a7e19fcf6399f628da7a60d755
  podLabels:
      app.elfhosted.com/name: letterboxd-trakt-sync    
  podAnnotations:
    elfbot.elfhosted.com/name: "Letterboxd Trakt Sync"
    elfbot.elfhosted.com/icon: "fas fa-film"  
    elfbot.elfhosted.com/category: Manage Media      
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-letterboxd-trakt-sync"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  env:
    RUN_ON_START: "true"
  envFrom:
  - configMapRef:
      name: elfbot-letterboxd-trakt-sync
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: letterboxd-trakt-sync
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-letterboxd-trakt-sync
          optional: true   
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: letterboxd-trakt-sync
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 100m # no way this should be using so much resources
      memory: 1Gi

decluttarr: &app_decluttarr
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/decluttarr
    tag: rolling@sha256:122813a18f3ad13aa043084451f806fe7524b664a55172c2efa7732bd7513e90
  podLabels:
      app.elfhosted.com/name: decluttarr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Decluttarr"
    elfbot.elfhosted.com/icon: "fas fa-trash-alt"     
    elfbot.elfhosted.com/category: Manage Media     
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-decluttarr,env-decluttarr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    tmp: *tmp
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  envFrom:
  - configMapRef:
      name: elfbot-decluttarr
      optional: true
  - configMapRef:
      name: env-decluttarr
      optional: true
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi

cleanuparr:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/cleanuparr
    tag: 2.0.19@sha256:5cc8764af50b7ca4279723a9d0fcde9e804634758baef0f904e462d3af72c052
  podLabels:
      app.elfhosted.com/name: cleanuparr
  podAnnotations:
    elfbot.elfhosted.com/name: "Cleanuparr"
    elfbot.elfhosted.com/icon: "fas fa-broom"  
    elfbot.elfhosted.com/category: Tools
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-cleanuparr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: cleanuparr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config   
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-cleanuparr
          optional: true               
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 11011
  envFrom:
  - configMapRef:
      name: elfbot-cleanuparr
      optional: true  
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: cleanuparr
      - mountPath: /tmp
        name: tmp         

suggestarr:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/suggestarr
    tag: v1.0.20@sha256:f567f7416f2e2092d54e68037e0886908ce583126281c9673c92bde0969bf1c5
  podLabels:
      app.elfhosted.com/name: suggestarr    
  podAnnotations:
    elfbot.elfhosted.com/name: "Suggestarr"
    elfbot.elfhosted.com/icon: "fas fa-lightbulb"  
    elfbot.elfhosted.com/category: Manage Downloads      
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work with app :(
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-suggestarr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  env:
    TZ: UTC
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /app/config/
      subPath: suggestarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /var/log
      subPath: suggestarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs          
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-suggestarr
          optional: true          
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5000
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: suggestarr
      - mountPath: /tmp
        name: tmp      

rcloneui:
  enabled: true
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/rclone
    tag: 1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-rcloneui,elfhosted-user-config"
  podLabels:
    app.elfhosted.com/name: rcloneui      
  podAnnotations:
    elfbot.elfhosted.com/name: "Rclone UI"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/rclone.png"  
    elfbot.elfhosted.com/category: Tools   
    kubernetes.io/egress-bandwidth: "40M"   
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    privileged: true
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    backup: *backup
    cache: 
      enabled: true
      type: emptyDir
      mountPath: /home/elfie/.cache
    mount:
      enabled: true
      type: emptyDir
      mountPath: /mount
      sizeLimit: 1Gi 
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: rclone
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    rclone-remote-storage:
      enabled: "true"
      subPath: "rclone-remote-storage"
      type: "custom"
      volumeSpec:
        configMap:
          name: rclonefm-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-rclonebrowser
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: rclone
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # add local remote if it doesn't exist
        grep -q '/storage' /config/rclone.conf || cat /rclone-remote-storage >> /config/rclone.conf

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: rclone
      - mountPath: /tmp # need this for cating into a file
        name: tmp
      - mountPath: /rclone-remote-storage
        subPath: rclone-remote-storage
        name: rclone-remote-storage
      resources: *default_resources
      securityContext: *default_securitycontext
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5572
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 60Mi
    limits:
      cpu: 1
      memory: 1Gi

rclonefm:
  enabled: true
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/rclone
    tag: 1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
  command:
  - /rclonefm.sh
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-rclonefm,rclonefm-config"
  podLabels:
      app.elfhosted.com/name: rclonefm      
  podAnnotations:
    elfbot.elfhosted.com/name: "Rclone FM"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/rclone.png"   
    elfbot.elfhosted.com/category: Tools     
    kubernetes.io/egress-bandwidth: "40M"
  # Always prefer to cohabit with zurg
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    cache:
      enabled: true
      type: emptyDir
      mountPath: /home/elfie/.cache
      sizeLimit: 1Gi
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: rclone
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    rclonefm-config:
      enabled: "true"
      mountPath: /var/lib/rclonefm/js/settings.js
      subPath: "settings.js"
      type: "custom"
      volumeSpec:
        configMap:
          name: rclonefm-config
    rclone-remote-storage:
      enabled: "true"
      subPath: "rclone-remote-storage"
      type: "custom"
      volumeSpec:
        configMap:
          name: rclonefm-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-rclonefm
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: rclone
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # add local remote if it doesn't exist
        grep -q '/storage' /config/rclone.conf || cat /rclone-remote-storage >> /config/rclone.conf

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: rclone
      - mountPath: /tmp # need this for cating into a file
        name: tmp
      - mountPath: /rclone-remote-storage
        subPath: rclone-remote-storage
        name: rclone-remote-storage
      resources: *default_resources
      securityContext: *default_securitycontext
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5573
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 60Mi
    limits:
      cpu: 150m
      memory: 512Mi

webdav: &webdav
  enabled:
    false
  podLabels:
    app.elfhosted.com/name: webdav
  podAnnotations:
    elfbot.elfhosted.com/name: "WebDAV"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/webdav.png"    
    elfbot.elfhosted.com/category: Tools
    kubernetes.io/egress-bandwidth: "40M"
  priorityClassName: tenant-normal
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  image:
    repository: ghcr.io/elfhosted/rclone
    tag: 1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-webdav-plus,elfbot-webdav"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  command:
  - /webdav.sh
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: webdav-config
  - configMapRef:
      name: elfbot-webdav
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /storage/config
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-webdav-plus
          optional: true
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
  service:
    main:
      enabled: false # necessary for probes
      ports:
        http:
          port: 5574
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 60Mi
    limits:
      cpu: 150m
      memory: 512Mi

webdavplus:
  enabled: false
  <<: *webdav
  podLabels:
    app.elfhosted.com/name: webdav-plus
  podAnnotations:
    elfbot.elfhosted.com/name: "WebDAV Plus"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/webdav.png" 
    elfbot.elfhosted.com/category: Tools   
    kubernetes.io/egress-bandwidth: "150M"
  envFrom:
  - configMapRef:
      name: webdav-plus-config

jfa:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/jfa-go
    tag: v0.5.1@sha256:ad4d6052d9fb27c0a7d972ecd4916aa0e51eb303a515e93a9a5e8a3ee80b1dd8
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-jfa"
  podLabels:
      app.elfhosted.com/name: jfa      
  podAnnotations:
    elfbot.elfhosted.com/name: "Jellyfin Accounts"
    elfbot.elfhosted.com/icon: "fas fa-user"     
    elfbot.elfhosted.com/category: Manage Media   
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: jfa
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-jfa
          optional: true
    tmp:
      enabled: true
      type: emptyDir
      mountPath: /tmp
      sizeLimit: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: jfa
      - mountPath: /tmp
        name: tmp
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8056
  resources:
    requests:
      cpu: 0m
      memory: 150Mi
    limits:
      cpu: 2
      memory: 1Gi

rdtclient: &app_rdtclient
  enabled: false
  hostname: elfhosted
  priorityClassName: tenant-bulk
  podLabels:
      app.elfhosted.com/name: rdtclient
  podAnnotations:
    elfbot.elfhosted.com/name: "RDTClient"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/rdtclient.png"   
    elfbot.elfhosted.com/category: Manage Downloads     
  image:
    repository: ghcr.io/elfhosted/rdtclient
    tag: v2.0.115@sha256:e2d6018595d5a74a447cb267f8240a7aa9f04f4e92d7ff008b6e8f1be02f3dba
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-rdtclient"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /data/db
      subPath: rdtclient
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-rdtclient
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 6500
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
      ephemeral-storage: 50Mi
    limits:
      cpu: 100m
      memory: 2Gi
      ephemeral-storage: 100Mi # a safety net against node ephemeral space exhaustion
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: rdtclient
      - mountPath: /tmp
        name: tmp

miniflux:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/miniflux
    tag: 2.2.11
  podLabels:
      app.elfhosted.com/name: miniflux    
  podAnnotations:
    elfbot.elfhosted.com/name: "Miniflux"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/miniflux.png"  
    elfbot.elfhosted.com/category: Tools      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-miniflux,miniflux-config"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1500m # if par threads is 1, this leaves 0.5cpu for downloading
      memory: 1Gi
  envFrom:
  - configMapRef:
      name: miniflux-config
  postgresql:
    enabled: true
    nameOverride: miniflux-postgresql
    commonAnnotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-miniflux"
    auth:
      username: miniflux
      password: miniflux
      database: miniflux
      postgresPassword: miniflux
    primary:
      affinity: *standard_affinity
      tolerations: *standard_tolerations
      persistence:
        enabled: true
        existingClaim: config
        subPath: miniflux/database
      resources:
        requests:
          cpu: 5m
          memory: 128Mi
        limits:
          cpu: 2
          memory: 1024Mi
      containerSecurityContext:
        enabled: true
        seccompProfile:
          type: RuntimeDefault
        runAsUser: 568
        runAsGroup: 568
      podSecurityContext:
        enabled: true
        runAsUser: 568
        runAsGroup: 568
        fsGroup: 568
      extraVolumeMounts:
      - mountPath: /opt/bitnami/postgresql/conf/
        name: conf
      - mountPath: /opt/bitnami/postgresql/tmp/
        name: tmp
      extraVolumes:
      - name: conf
        emptyDir:
          sizeLimit: 1Gi
      - name: tmp
        emptyDir:
          sizeLimit: 1Gi
      sidecars:
        - name: backup-database
          image: *tooling_image
          env:
            - name: POSTGRES_PASSWORD
              value: miniflux
            - name: POSTGRES_DATABASE
              value: miniflux
            - name: POSTGRES_USER
              value: miniflux
          command:
          - /usr/bin/dumb-init
          - /bin/bash
          - -c
          - |

            set +e # for debug
            sleep 2m # give postgres time to start up
            while true
            do
              now=$(date +"%s_%Y-%m-%d")
              PGPASSWORD=$POSTGRES_PASSWORD pg_dump -U $POSTGRES_USER -h localhost -d $POSTGRES_DATABASE -F c -f /backup/${now}_${POSTGRES_DATABASE}.psql
              sleep 1d
            done

homepage:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/gethomepage/homepage
    tag: v1.4.0
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-homepage,homepage-config,homepage-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false
    privileged: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    # runAsUser: 568
    # runAsGroup: 568
    fsGroup: 568 # need this so that the bootstrap can run
    fsGroupChangePolicy: "OnRootMismatch"
  serviceAccount:
    create: true
    name: homepage
  automountServiceAccountToken: true
  env:
    PUID: 568
    PGID: 568
  envFrom:
  - configMapRef:
      name: homepage-env
  - configMapRef:
      name: elfbot-homepage
      optional: true
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /app/config
      subPath: homepage
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    config-default:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: homepage-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-homepage
          optional: true
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3000
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 250m # deliberately hobble the CPU in favor of GPU transcoding
      memory: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: homepage
      - mountPath: /tmp
        name: tmp
    copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        mkdir -p /app/config/user-change-these/
        touch /app/config/user-change-these/JELLYFIN_KEY
        touch /app/config/user-change-these/PLEX_KEY
        touch /app/config/user-change-these/EMBY_KEY
        touch /app/config/user-change-these/NAVIDROME_USER
        touch /app/config/user-change-these/NAVIDROME_TOKEN
        touch /app/config/user-change-these/NAVIDROME_SALT
        touch /app/config/user-change-these/CALIBREWEB_USERNAME
        touch /app/config/user-change-these/CALIBREWEB_PASSWORD
        touch /app/config/user-change-these/KOMGA_USERNAME
        touch /app/config/user-change-these/KOMGA_PASSWORD
        touch /app/config/user-change-these/KAVITA_USERNAME
        touch /app/config/user-change-these/KAVITA_PASSWORD
        touch /app/config/user-change-these/AUDIOBOOKSHELF_KEY
        touch /app/config/user-change-these/OMBI_KEY
        touch /app/config/user-change-these/OVERSEERR_KEY
        touch /app/config/user-change-these/JELLYSEERR_KEY
        touch /app/config/user-change-these/TAUTULLI_KEY
        touch /app/config/user-change-these/tunarr_USERNAME
        touch /app/config/user-change-these/tunarr_PASSWORD
        touch /app/config/user-change-these/MINIFLUX_KEY
        touch /app/config/user-change-these/UPTIMEKUMA_SLUG
        touch /app/config/user-change-these/GOTIFY_KEY

        # If we don't already have an example config, create one
        if [ ! -f /app/config/dont-overwrite-me ];
        then
          cp /bootstrap/* /app/config/
        fi
      volumeMounts:
      - mountPath: /app/config
        name: config
        subPath: homepage
      - name: config-default
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true


wallabag:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: stefanprodan/podinfo
    tag: latest
  podLabels:
      app.elfhosted.com/name: wallabag    
  podAnnotations:
    elfbot.elfhosted.com/name: "Wallabag"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/wallabag.png"   
    elfbot.elfhosted.com/category: Tools     
  controller:  
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-wallabag,wallabag-config"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false
    privileged: false
  # runtimeClassName: kata
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568 # for the mounted volumes
  persistence:
    config:
      enabled: true
      type: custom
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  resources:
    requests:
      cpu: 0m
      memory: 32Mi
    limits:
      cpu: 100m
      memory: 1Gi
  additionalContainers:
    ui:
      image: ghcr.io/elfhosted/wallabag:2.6.12@sha256:3398b2af57d0e51727ebaf2d674c71566718040c685e01a26db532bd4848ebcb
      volumeMounts:
      - mountPath: /var/www/wallabag/data
        name: config
        subPath: wallabag/data
      - mountPath: /var/www/wallabag/images
        name: config
        subPath: wallabag/images
      envFrom:
      - configMapRef:
          name: elfbot-wallbag
          optional: true
      - configMapRef:
          name: wallabag-config
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        allowPrivilegeEscalation: false
      resources:
        requests:
          cpu: 0m
          memory: 100Mi
        limits:
          cpu: 500m
          memory: 200Mi

gotosocial:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/gotosocial
    tag: 0.19.0@sha256:538111e5b96b5dd7bf6142bcaf1de1aa86180d5d3d09e20d76425cc38036cb9e
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: gotosocial  
  podAnnotations:
    elfbot.elfhosted.com/name: "GoToSocial"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/gotosocial.png"   
    elfbot.elfhosted.com/category: Tools     
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-gotosocial"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # doesn't work with s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 16Mi
    limits:
      cpu: 1
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  env:
    S6_READ_ONLY_ROOT: "true"
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: gotosocial
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: gotosocial-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-gotosocial
          optional: true
    run: # used for s6-init with non-root
      enabled: true
      type: emptyDir
      mountPath: /run
      sizeLimit: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: gotosocial
      - mountPath: /tmp
        name: tmp
    copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # If we don't already have an example config, create one
        if [[ ! -f /config/config.yaml ]];
        then
          cp /bootstrap/config.yaml /config/
        fi

        # Setup the fish env
        mkdir -p /config/.config/fish
        cp /bootstrap/config.fish /config/.config/fish
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: gotosocial
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /livez
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /readyz
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 60 # allow 10 min of failures to start up
        httpGet:
          path: /readyz
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10  

blueskypds:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/bluesky-pds
    tag: 0.4.163@sha256:e1904a08b2ff610682f659f70de55c839b0f56564a17bef526cee8609d87920b
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: bluesky-pds  
  podAnnotations:
    elfbot.elfhosted.com/name: "Bluesky PDS"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/bluesky.png"  
    elfbot.elfhosted.com/category: Tools      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-bluesky-pds"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # doesn't work with s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 16Mi
    limits:
      cpu: 1
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  env:
    S6_READ_ONLY_ROOT: "true"
  envFrom:
  - configMapRef:
      name: bluesky-pds-env
  - configMapRef:
      name: elfbot-bluesky-pds
      optional: true    
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: bluesky-pds
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-bluesky-pds
          optional: true
    run: # used for s6-init with non-root
      enabled: true
      type: emptyDir
      mountPath: /run
      sizeLimit: 1Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: bluesky-pds
      - mountPath: /tmp
        name: tmp
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /xrpc/_health
          port: 3000
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /xrpc/_health
          port: 3000
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 60 # allow 10 min of failures to start up
        httpGet:
          path: /xrpc/_health
          port: 3000
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10  

riven: &app_riven
  enabled: false
  podLabels:
    app.elfhosted.com/name: riven
  podAnnotations:
    elfbot.elfhosted.com/name: "Riven"
    elfbot.elfhosted.com/icon: "fas fa-mountain"    
    elfbot.elfhosted.com/category: Manage Downloads  
  image:
    repository: ghcr.io/elfhosted/riven
    tag: v0.21.21@sha256:bf1a9cab579d5eaac0ed72e20584b139547db7c38753a03b3756151af5e0ac13
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-riven,riven-env,riven-setup"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work with ilikedanger currently
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: riven-env
  - configMapRef:
      name: elfbot-riven
      optional: true
  resources:
    requests:
      cpu: 0m
      memory: 20Mi
    limits:
      cpu: 2
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /riven/data
      subPath: riven
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /riven/data/logs
      subPath: riven
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-riven
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory
    setup:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: riven-setup        
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: riven
      - mountPath: /tmp
        name: tmp
    setup-postgres:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        mkdir -p /config/postgresql/database
        mkdir -p /config/postgresql/backups
        chown elfie:elfie /config -R

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: riven
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault
    setup:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        # run the setup script from the configmap, so that we can make templated changes
        bash /setup/setup.sh
      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      - mountPath: /config
        name: config
        subPath: riven
      - name: setup
        mountPath: "/setup/"              
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: postgres
        - name: POSTGRES_DB
          value: riven
        - name: POSTGRES_USER
          value: postgres
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: riven/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi 

mediamanager: 
  enabled: false
  podLabels:
    app.elfhosted.com/name: media-manager
  podAnnotations:
    elfbot.elfhosted.com/name: "Media Manager"
    elfbot.elfhosted.com/icon: "fas fa-film"      
    elfbot.elfhosted.com/category: Manage Media
  image:
    repository: ghcr.io/elfhosted/media-manager
    tag: v1.7.0@sha256:110ada55cd019a6456e36d915c36119fcf26b323d0841d3839c90a8f8360716b
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-media-manager,media-manager-env,media-manager-config"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work with ilikedanger currently
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  env:
    CONFIG_FILE: /config/config.toml
  resources:
    requests:
      cpu: 0m
      memory: 20Mi
    limits:
      cpu: 1
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: media-manager
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-media-manager
          optional: true
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: media-manager-config    
    cache:
      enabled: true
      type: emptyDir
      sizeLimit: 1Gi
      mountPath: /.cache               
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: media-manager
      - mountPath: /tmp
        name: tmp
    a-copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # If we don't already have an example config, create one
        if [ ! -f /config/config.toml];
        then
          cp /bootstrap/config.toml /config/
        fi
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: media-manager
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true        
    setup-postgres:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        mkdir -p /config/postgresql/database
        mkdir -p /config/postgresql/backups
        chown elfie:elfie /config -R

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: media-manager
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault           
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310      
      env:
        - name: POSTGRES_PASSWORD
          value: media-manager
        - name: POSTGRES_DB
          value: media-manager
        - name: POSTGRES_USER
          value: postgres
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: media-manager/postgresql/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi 

rivenvpn: 
  enabled: false
  <<: *app_riven
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-riven,riven-env,riven-setup,gluetun-config"  
  addons:
    vpn:
      enabled: true
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      envFrom:
      - configMapRef:
          name: gluetun-config
      env:
        DOT: "off"
        FIREWALL_INPUT_PORTS: "3001,8080" # 3001 is ttyd, 8080 is the backend
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        HEALTH_SERVER_ADDRESS: "127.0.0.1:9991"
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"        
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config

rivenfrontend: &app_rivenfrontend
  podLabels:
    app.elfhosted.com/name: riven-frontend
  podAnnotations:
    elfbot.elfhosted.com/name: "Riven Frontend"
    elfbot.elfhosted.com/icon: "fas fa-mountain"   
    elfbot.elfhosted.com/category: Manage Downloads    
  image:
    repository: ghcr.io/elfhosted/riven-frontend
    tag: v0.20.0@sha256:c4d792868a8113a2f57f504fe371cbcd8c52172d734c812c366bff352672998e
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-rivenfrontend,riven-frontend-env,riven-frontend-config"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work with ilikedanger currently
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    config:
      enabled: "true"
      type: "custom"
      mountPath: /riven/config
      volumeSpec:
        configMap:
          name: riven-frontend-config          
  envFrom:
  - configMapRef:
      name: riven-frontend-env
  - configMapRef:
      name: elfbot-rivenfrontend
      optional: true
  resources:
    requests:
      cpu: 0m
      memory: 20Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3000

# So that we can toggle it on with rivenvpn
rivenfrontendvpn:
  enabled: false
  <<: *app_rivenfrontend

airdcpp: &app_airdcpp
  enabled: false
  image:
    repository: ghcr.io/geek-cookbook/airdcpp
    tag: 2.9.0@sha256:d9f6e597bcfc38946d0c4cafce775a559e7b8cf7c66397c9c506cb695ea01205
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: airdcpp
  podAnnotations:
    elfbot.elfhosted.com/name: "AirDC++"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/airdcpp.png" 
    elfbot.elfhosted.com/category: Manage Downloads     
  podAnnotations:
    kubernetes.io/egress-bandwidth: "100M"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-airdcpp"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 16Mi
    limits:
      cpu: 2
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5600
  env:
    WAIT_FOR_VPN: "true"
    PORT_FILE: /.airdcpp/forwarded-port
  probes:
    liveness:
      enabled: false
    startup:
      enabled: false
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /.airdcpp/
      subPath: airdcpp
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-airdcpp
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: airdcpp
      - mountPath: /tmp
        name: tmp
  addons:
    vpn:
      enabled: true # in case we ever need it
      gluetun:
        image:
          repository: thrnz/docker-wireguard-pia
          tag: latest
      envFrom:
      - configMapRef:
          name: airdcpp-pia-config
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      additionalVolumeMounts:
      - mountPath: /config
        name: config
        subPath: airdcpp
      scripts:
        up: |-
          #!/bin/ash
          echo "connected" > /shared/vpnstatus

        down: |-
          #!/bin/ash
          echo "disconnected" > /shared/vpnstatus

airdcpppia:
  enabled: false
  <<: *app_airdcpp

airdcppgluetun:
  enabled: false
  <<: *app_airdcpp
  addons:
    vpn:
      enabled: true # in case we ever need it
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      envFrom:
      - configMapRef:
          name: airdcpp-gluetun-config
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      additionalVolumeMounts:
      - mountPath: /config
        name: config
        subPath: airdcpp
      scripts:
        up: |-
          #!/bin/ash
          echo "connected" > /shared/vpnstatus

        down: |-
          #!/bin/ash
          echo "disconnected" > /shared/vpnstatus

jackett:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/jackett
    tag: 0.22.2217@sha256:afde5e316ac100fe94096c408a89b16cf59ef163f30703101394458ff2c6a282
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: jackett  
  podAnnotations:
    elfbot.elfhosted.com/name: "Jackett"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jackett.png"     
    elfbot.elfhosted.com/category: Manage Downloads   
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-jackett"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  # Always prefer to cohabit with zurg
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9117
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: jackett
      volumeSpec:
        persistentVolumeClaim:
          claimName: config        
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-jackett
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: jackett
      - mountPath: /tmp
        name: tmp

wizarr:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/wizarr
    tag: 2025.7.8@sha256:9d878ead1ee61eb1607081c1f421d74bd70deecb0aebcc685b8daa543b0aac44
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: wizarr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Wizarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/wizarr.png"   
    elfbot.elfhosted.com/category: Tools     
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-wizarr"
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # now wizarr wants to write data to /data/.venv
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1024Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5690
  envFrom:
  - configMapRef:
      name: wizarr-env
  - configMapRef:
      name: elfbot-wizarr
      optional: true            
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /data/database
      subPath: wizarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config        
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-wizarr
          optional: true
    wizarr-steps:
      enabled: true
      type: emptyDir
      mountPath: /data/wizard_steps          
    wizarr-steps-plex:
      enabled: "true"
      type: "custom"
      mountPath: /opt/default_wizard_steps/plex
      volumeSpec:
        configMap:
          name: wizarr-steps-plex
    wizarr-steps-jellyfin:
      enabled: "true"
      type: "custom"
      mountPath: /opt/default_wizard_steps/jellyfin
      volumeSpec:
        configMap:
          name: wizarr-steps-jellyfin
    cache:
      enabled: true
      type: emptyDir
      mountPath: /.cache     
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: wizarr
      - mountPath: /tmp
        name: tmp        

flixio:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/stremio-web
    tag: rolling@sha256:de20030d591000b871519899ccbcead9e958a8e1eb5e98d05b65e033286a7e2a
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: flixio
  podAnnotations:
    elfbot.elfhosted.com/name: "Flixio"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/stremio.png"  
    elfbot.elfhosted.com/category: Consume Media    
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-flixio"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work with iprom's patching trick
    privileged: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: flixio-env
  - configMapRef:
      name: elfbot-flixio
      optional: true  
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 2
      memory: 2Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080

flixioapi:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/flixio-api
    tag: rolling@sha256:0e30427d9c311f806610951cfc8d8a71c1ba6b65c3ea1a93b829ed75e37138c9
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: flixio-api
  podAnnotations:
    elfbot.elfhosted.com/name: "Flixio API"
    elfbot.elfhosted.com/icon: "fas fa-code" 
    elfbot.elfhosted.com/category: Consume Media     
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-flixio-api"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
    runAsUser: 568
    runAsGroup: 568
  automountServiceAccountToken: false
  persistence:
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-flixio-api
          optional: true
    config:
      enabled: true
      type: custom
      mountPath: /app/data
      subPath: flixio-api
      volumeSpec:
        persistentVolumeClaim:
          claimName: config   
  envFrom:
  - configMapRef:
      name: flixio-api-env
  - configMapRef:
      name: elfbot-flixio-api
      optional: true           
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080

pairdrop:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/pairdrop
    tag: v1.11.2@sha256:d4e52400813a6af412433a801645cd59e7ad27e3e73540af698e085125eead8c
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: pairdrop
  podAnnotations:
    elfbot.elfhosted.com/name: "PairDrop"
    elfbot.elfhosted.com/icon: "fas fa-lock" 
    elfbot.elfhosted.com/category: Tools     
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-pairdrop"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  # envFrom:
  # - configMapRef:
  #     name: pairdrop-env
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3000
  persistence:
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-pairdrop
          optional: true

actual:
  enabled: false
  image:
    repository: ghcr.io/actualbudget/actual-server
    tag: 25.7.1-alpine
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: actual
  podAnnotations:
    elfbot.elfhosted.com/name: "Actual Budget"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/actual-budget.png"  
    elfbot.elfhosted.com/category: Tools    
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-actual"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: elfbot-actual
      optional: true    
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5006
  persistence:
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-actual
          optional: true
    config:
      enabled: true
      type: custom
      mountPath: /data
      subPath: actual
      volumeSpec:
        persistentVolumeClaim:
          claimName: config     
    api-data:
      enabled: true
      type: emptyDir     
  additionalContainers:
    api:
      image: ghcr.io/elfhosted/actual-http-api:25.7.1@sha256:39a75e02129af32cb8d4b7a54c41e3e8403ba4b3cb7a9cc482ab30dd91295745
      securityContext: *default_securitycontext
      envFrom:
      - configMapRef:
          name: elfbot-actual
          optional: true   
      volumeMounts:
      - mountPath: /data
        name: api-data
          
elfbot:
  enabled: true
  image:
    repository: ghcr.io/elfhosted/elfbot
    tag: v1.0.11@sha256:473d5c2e7e6f104ff058074426ac4e5097ebf9ffe1ca2361cbe6e274c9b0e4bc
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  priorityClassName: tenant-normal
  serviceAccount:
    name: elfbot
    create: true
  automountServiceAccountToken: true  
  podLabels:
    app.elfhosted.com/name: elfbot
  podAnnotations:
    elfbot.elfhosted.com/name: "ElfBot (me!)"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/elfbot.png"   
    elfbot.elfhosted.com/category: Tools   
  persistence:
    <<: *storagemounts    
    config:
      enabled: true
      type: custom
      mountPath: /storage/config/
      volumeSpec:
        persistentVolumeClaim:
          claimName: config    
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  envFrom:
  - configMapRef:
      name: elfbot-env
  env:
  - name: POD_NAMESPACE
    valueFrom:
      fieldRef:
        fieldPath: metadata.namespace      
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3000   

petio:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/petio
    tag: v0.5.5@sha256:a28b7ffb5b1b04a8ad798112604c410a9a09f8882e9bf98b9f24e8f41571f505
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: petio  
  podAnnotations:
    elfbot.elfhosted.com/name: "Petio"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/petio.png"    
    elfbot.elfhosted.com/category: Manage Media    
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-petio"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 7777
  persistence:
    backup: *backup
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-petio
          optional: true
    config:
      enabled: true
      type: custom
      mountPath: /app/api/config/
      subPath: petio/config
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    tmp: *tmp
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: petio
      - mountPath: /tmp
        name: tmp
  additionalContainers:
    mongodb:
      image: mongodb/mongodb-community-server:8.0.11-ubi8
      volumeMounts:
        - name: config
          subPath: petio/mongodb
          mountPath: /data/db/
        - name: tmp
          mountPath: /tmp
      securityContext: *default_securitycontext

nightscout:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/nightscout
    tag: 15.0.3@sha256:9fb5de043a782232738fc7fc185a0f4d9655de7ae3177fed5b3c13fe51840ee3
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: nightscout  
  podAnnotations:
    elfbot.elfhosted.com/name: "NightScout"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/nightscout.png" 
    elfbot.elfhosted.com/category: Tools       
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-nightscout,nightscout-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: nightscout-env
  - configMapRef:
      name: elfbot-nightscout
      optional: true  
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 1337
  persistence:
    tmp: *tmp
    config:
      enabled: true
      type: custom
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
  additionalContainers:
    mongodb:
      image: mongodb/mongodb-community-server:8.0.11-ubi8
      volumeMounts:
        - name: config
          subPath: nightscout/mongodb
          mountPath: /data/db/
        - name: tmp
          mountPath: /tmp
      securityContext: *default_securitycontext

pgadmin:
  enabled: false
  image:
    repository: dpage/pgadmin4
    tag: "9.6"
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: pgadmin  
  podAnnotations:
    elfbot.elfhosted.com/name: "PGAdmin"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/pgaddmin.png"   
    elfbot.elfhosted.com/category: Tools     
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-pgadmin"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
    capabilities:
      add:
      - NET_BIND_SERVICE
      drop:
      - ALL
  automountServiceAccountToken: false
  envFrom:
  - configMapRef:
      name: pgadmin-env
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 80
  persistence:
    config:
      enabled: true
      type: custom
      mountPath: /data
      subPath: pgadmin
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    tmp: *tmp

redisinsight:
  enabled: false
  image:
    repository: redislabs/redisinsight
    tag: v2@sha256:7fef8b7ecf2e8597037f906fc69863345dd846d36577210569396f7917333355
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: redisinsight  
  podAnnotations:
    elfbot.elfhosted.com/name: "RedisInsight"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/redis.png"  
    elfbot.elfhosted.com/category: Tools      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-redisinsight"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
    capabilities:
      add:
      - IPC_LOCK
      drop:
      - ALL
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5540
  persistence:
    config:
      enabled: true
      type: custom
      mountPath: /data
      subPath: redisinsight
      volumeSpec:
        persistentVolumeClaim:
          claimName: config

mongoexpress:
  enabled: false
  image:
    repository: mongo-express
    tag: 1.0.2-18
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: mongoexpress  
  podAnnotations:
    elfbot.elfhosted.com/name: "Mongo Express"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/mongo.png"
    elfbot.elfhosted.com/category: Tools        
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-mongoexpress"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8081
  envFrom:
  - configMapRef:
      name: elfbot-mongoexpress
      optional: true

comet:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/comet
    tag: v2.10.0@sha256:e59c6edf6a8a33313a8b785505b5caf3d516f573346a9bfd3d95a966eb8c3086
  priorityClassName: tenant-normal
  podAnnotations:
    kubernetes.io/egress-bandwidth: "150M"
    elfbot.elfhosted.com/name: "Comet"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/comet.png"
    elfbot.elfhosted.com/category: Consume Media
  podLabels:
      app.elfhosted.com/name: comet
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-comet,comet-env"
      secret.reloader.stakater.com/reload: "comet-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568    
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
    config:
      enabled: true
      type: custom
      mountPath: /app/data
      subPath: comet
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    cache:
      enabled: true
      type: emptyDir
      mountPath: /.cache
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-comet
          optional: true
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory          
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 2
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  envFrom:
  - configMapRef:
      name: comet-env
  - secretRef:
      name: comet-env
  - configMapRef:
      name: elfbot-comet
      optional: true
  initContainers:
    setup-warp: *setup_warp
  addons:
    vpn:
      enabled: true
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8001"
        HTTP_CONTROL_SERVER_ADDRESS: ":8001"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "8000"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own confi
      volumeMounts:
      - mountPath: /shared
        name: shared  

jackettio:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/jackettio
    tag: v1.7.1@sha256:6bff317e8c7eb286cf53a8e1740a9b06092e2d3536f80168c728bfeb04a54289
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: jackettio  
  podAnnotations:
    elfbot.elfhosted.com/name: "Jackettio"
    elfbot.elfhosted.com/icon: "fas fa-search"
    elfbot.elfhosted.com/category: Consume Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-jackettio,jackettio-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: jackettio
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory              
  resources:
    requests:
      cpu: 10m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 4000
  envFrom:
  - configMapRef:
      name: jackettio-env
  - configMapRef:
      name: elfbot-jackettio
      optional: true
  initContainers:      
    setup-warp: *setup_warp 
  addons:
    vpn:
      enabled: true # in case we ever need it
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "4000"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      volumeMounts:
      - mountPath: /shared
        name: shared

stremthru:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/stremthru
    tag: 0.82.0@sha256:39dd61b7773ea50fbfa7a3fc59490143a3d3c1a7f64c717201f520a8fd556a15
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: stremthru  
  podAnnotations:
    elfbot.elfhosted.com/name: "StremThru"
    elfbot.elfhosted.com/icon: "fas fa-tools"
    elfbot.elfhosted.com/category: Consume Media        
    kubernetes.io/egress-bandwidth: "150M"  
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-stremthru,stremthru-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: stremthru
      volumeSpec:
        persistentVolumeClaim:
          claimName: config      
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755           
    # shared:
    #   enabled: true
    #   mountPath: /shared
    #   type: emptyDir
    #   volumeSpec:
    #     medium: Memory                    
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  envFrom:
  - configMapRef:
      name: stremthru-env
  - configMapRef:
      name: elfbot-stremthru
      optional: true
  - secretRef:
      name: stremthru-env      
  addons:
    vpn:
      enabled: false # in case we ever need it
      gluetun:
        image:
          repository: thrnz/docker-wireguard-pia
          tag: latest
      env:
        IPTABLES_BACKEND: nft
        KILLSWITCH: "true"
        LOCAL_NETWORK: 10.0.0.0/8
        LOC: de-frankfurt
        PORT_FORWARDING: "0"
        PORT_PERSIST: "1"
        NFTABLES: "1"
        VPNDNS: "0"
      envFrom:
      - secretRef:
          name: stremthru-vpn
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
  additionalContainers:
    speedtest:
      image: openspeedtest/latest:latest@sha256:1745e913f596fe98882b286a67751efdae74774e9caa742a4934bb056e8748d2
      imagePullPolicy: IfNotPresent
      env:
        CHANGE_CONTAINER_PORTS: "True"
        HTTP_PORT: "3002"
        HTTPS_PORT: "3003"    
      securityContext: *speedtest_securitycontext  

davio:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/davio
    tag: v1.0.4@sha256:3508249d413b6b55bb2860358bbb92dd8ccd760969fadb0473540ddb74218523
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: davio  
  podAnnotations:
    elfbot.elfhosted.com/name: "Davio"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/davio.png"  
    elfbot.elfhosted.com/category: Consume Media      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-davio,davio-env"
      secret.reloader.stakater.com/reload: "davio-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    config:
      enabled: true
      mountPath: /config
      type: emptyDir
      volumeSpec:
        medium: Memory      
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 4000
  envFrom:
  - configMapRef:
      name: davio-env
  - secretRef:
      name: davio-env
  - configMapRef:
      name: elfbot-davio
      optional: true

mediafusion:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/mediafusion
    tag: 4.3.33@sha256:f29a06e3ce4649fa26f8573ae1f7a3da0ba1fecc4604d5186df8a49576a83869
  podLabels:
      app.elfhosted.com/name: mediafusion
  podAnnotations:
    elfbot.elfhosted.com/name: "MediaFusion"
    elfbot.elfhosted.com/icon: "fas fa-atom"        
    elfbot.elfhosted.com/category: Consume Media
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-mediafusion,mediafusion-env"
      secret.reloader.stakater.com/reload: "mediafusion-env,mediafusion-vpn"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_anti_affinity 
  tolerations: *standard_tolerations      
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    tinyproxy-conf:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tinyproxy-conf 
  resources:
    requests:
      cpu: 1m
      memory: 150Mi
    limits:
      cpu: 100m
      memory: 256Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  # Attempmt to reduce load spike on restarts
  command: ["gunicorn", "api.main:app", "-w", "1", "-k", "uvicorn.workers.UvicornWorker", "--bind", "0.0.0.0:8000", "--timeout", "120", "--max-requests", "2500", "--max-requests-jitter", "500"]          
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 8000
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 8000
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 8000
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10           
  envFrom:
  - configMapRef:
      name: mediafusion-env
  - configMapRef:
      name: elfbot-mediafusion
      optional: true
  - secretRef:
      name: mediafusion-env

piaproxy:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: thrnz/docker-wireguard-pia
    tag: latest
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "piaproxy-conf"
      secret.reloader.stakater.com/reload: "piaproxy-vpn"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations    
  env:
    IPTABLES_BACKEND: nft
    KILLSWITCH: "true"
    LOCAL_NETWORK: 10.0.0.0/8
    LOC: de-frankfurt
    PORT_FORWARDING: "0"
    PORT_PERSIST: "1"
    NFTABLES: "1"
    VPNDNS: "0"
  envFrom:
  - secretRef:
      name: piaproxy-vpn
  securityContext:
    privileged: true
    runAsUser: 0
    capabilities:
      add:
        - NET_ADMIN
        - SYS_MODULE
  persistence:
    tinyproxy-conf:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tinyproxy-conf 
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8888
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        exec:
          command:
          - /bin/bash
          - -c
          - curl -x http://localhost:8888 -s https://www.cloudflare.com/cdn-cgi/trace | grep www.cloudflare.com
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
  additionalContainers:
    tinyproxy:
      image: ghcr.io/elfhosted/tinyproxy:v1.4.3@sha256:262bbdc0e468ee97c049203becc52b9ad7bf4c21405d58c82766d1aebb2e27e5
      volumeMounts:
      - mountPath: /etc/tinyproxy/tinyproxy.conf
        name: tinyproxy-conf
        subPath: tinyproxy.conf
      - mountPath: /shared
        name: shared
      # env:
      #   WAIT_FOR_VPN: "true"

vpnproxy:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/gluetun
    tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-vpnproxy"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations    
  securityContext:
    privileged: true
    runAsUser: 0
    capabilities:
      add:
        - NET_ADMIN
        - SYS_MODULE
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory          
  resources:
    requests:
      cpu: 0m
      memory: 512Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8888
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        exec:
          command:
          - /bin/ash
          - -c
          - curl -x http://localhost:8888 -s https://www.cloudflare.com/cdn-cgi/trace | grep www.cloudflare.com
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10            
  env:
    VPN_TYPE: wireguard
    VPN_SERVICE_PROVIDER: custom
    VPN_ENDPOINT_PORT: "2408"
    HTTPPROXY: "on"
    FIREWALL_INPUT_PORTS: "8888"
    DOT: "off"
  initContainers:      
    setup-warp: *setup_warp

tinyproxy:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/tinyproxy
    tag: v1.4.3@sha256:262bbdc0e468ee97c049203becc52b9ad7bf4c21405d58c82766d1aebb2e27e5
  podLabels:
      app.elfhosted.com/name: tinyproxy
  podAnnotations:
    elfbot.elfhosted.com/name: "TinyProxy"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/tinyproxy.png"  
    elfbot.elfhosted.com/category: Tools      
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "tinyproxy-conf"
      secret.reloader.stakater.com/reload: "tinyproxy-vpn"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    tinyproxy-conf:
      enabled: "true"
      type: "custom"
      mountPath: /etc/tinyproxy/tinyproxy.conf
      subPath: tinyproxy.conf  
      volumeSpec:
        configMap:
          name: tinyproxy-conf 
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory          
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8888
  env:
    WAIT_FOR_VPN: "true"    
  initContainers:      
    setup-warp: *setup_warp
  addons:
    vpn:
      enabled: true # in case we ever need it
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "8888"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      volumeMounts:
      - mountPath: /shared
        name: shared

mediaflowproxy:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/mediaflow-proxy
    tag: 2.1.7@sha256:309c6125465b2dec77f7aaa4cbef4ba8fecb83ff6dc241c7f72dbf999b9476a7
  podLabels:
      app.elfhosted.com/name: mediaflow-proxy
  priorityClassName: tenant-normal
  podAnnotations:
    kubernetes.io/egress-bandwidth: "150M"
    elfbot.elfhosted.com/name: "MediaFlow Proxy"
    elfbot.elfhosted.com/icon: "fas fa-cloud"
    elfbot.elfhosted.com/category: Consume Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-mediaflow-proxy,mediaflow-proxy-env"
      secret.reloader.stakater.com/reload: "mediaflowproxy-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
  additionalContainers:
    speedtest:
      image: openspeedtest/latest:latest@sha256:1745e913f596fe98882b286a67751efdae74774e9caa742a4934bb056e8748d2
      imagePullPolicy: IfNotPresent
      env:
        CHANGE_CONTAINER_PORTS: "True"
        HTTP_PORT: "3002"
        HTTPS_PORT: "3003"    
      securityContext: *speedtest_securitycontext
  resources:
    requests:
      cpu: 100m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8888
  envFrom:
  - configMapRef:
      name: mediaflow-proxy-env
  - configMapRef:
      name: elfbot-mediaflow-proxy
      optional: true   

youriptv:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/youriptv-nobranding
    tag: rolling@sha256:b5b7cb9858e5d6b2edd636f6167ef1e78198deb0badea677256a50613b43211e
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: youriptv  
  podAnnotations:
    elfbot.elfhosted.com/name: "YourIPTV"
    elfbot.elfhosted.com/icon: "fas fa-tv"
    elfbot.elfhosted.com/category: Consume Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-youriptv"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  env:
    PORT: 3649
  persistence:
    tmp: *tmp
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3649

aiostreams:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/aiostreams
    tag: v2.8.2@sha256:a5915a0b05d9b282bf3ae6b3cabb86969320a457f72933da63932dcf05d94457
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: aiostreams  
  podAnnotations:
    elfbot.elfhosted.com/name: "AIOStreams"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/aiostreams.png" 
    elfbot.elfhosted.com/category: Consume Media       
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-aiostreams,aiostreams-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    tmp: *tmp
    backup: *backup    
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: aiostreams
      volumeSpec:
        persistentVolumeClaim:
          claimName: config  
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-aiostreams
          optional: true     
    shared:
      enabled: true
      type: emptyDir
      volumeSpec:
        medium: Memory                 
  resources:
    requests:
      cpu: 0m
      memory: 50Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3000
  envFrom:
  - configMapRef:
      name: aiostreams-env   
  - configMapRef:
      name: elfbot-aiostreams
      optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: aiostreams
      - mountPath: /tmp
        name: tmp
    setup-warp: *setup_warp
  addons:
    vpn:
      enabled: true
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "3000"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      volumeMounts:
      - mountPath: /shared
        name: shared        

autopulse:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/autopulse
    tag: v1.3.2@sha256:2f6e2e0ea0648a33b9a26688853851a2963c8c3b7f1b325e896b46333e2e8fc2
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: autopulse  
  podAnnotations:
    elfbot.elfhosted.com/name: "AutoPulse"
    elfbot.elfhosted.com/icon: "fas fa-heartbeat"
    elfbot.elfhosted.com/category: Manage Downloads
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-autopulse,autopulse-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    # runAsUser: 568
    # runAsGroup: 568
    # fsGroup: 568
    # fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  persistence:
    tmp: *tmp
    backup: *backup    
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: autopulse
      volumeSpec:
        persistentVolumeClaim:
          claimName: config  
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-autopulse
          optional: true     
    run: # used for s6-init with non-root
      enabled: true
      type: emptyDir
      mountPath: /run
      sizeLimit: 1Gi                 
  resources:
    requests:
      cpu: 0m
      memory: 50Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 2875
  envFrom:
  - configMapRef:
      name: autopulse-env   
  - configMapRef:
      name: elfbot-autopulse
      optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: autopulse
      - mountPath: /tmp
        name: tmp
  additionalContainers:
    ui:
      image: ghcr.io/elfhosted/autopulse-ui:v1.3.2@sha256:53a1f11001f0eab374c65f08c19a917e3f9ac4bd480561aab91efbd83ef99f6f
      envFrom:
      - configMapRef:
          name: autopulse-env

nuviostreams:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/nuviostreams-dev
    tag: rolling@sha256:163f35d0b0653a9c89a9fb590a9124910a4ab4ddb863808bc41394acd1db2e3d
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: nuviostreams        
  podAnnotations:
    elfbot.elfhosted.com/name: "NuvioStreams"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/nuviostreams.png"    
    elfbot.elfhosted.com/category: Consume Media
    kubernetes.io/egress-bandwidth: "150M" 
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-nuviostreams,nuviostreams-env"
    strategy:
    rollingUpdate:
      unavailable: 1
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  affinity: *standard_affinity
  tolerations: *standard_tolerations  
  persistence:
    tmp: *tmp
    shared:
      enabled: true
      type: emptyDir
      volumeSpec:
        medium: Memory     
  resources:
    requests:
      cpu: 0m
      memory: 50Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 7777
  envFrom:
  - configMapRef:
      name: nuviostreams-env   
  - secretRef:
      name: nuviostreams-env         
  - configMapRef:
      name: elfbot-nuviostreams
      optional: true
  additionalContainers:
    proxy:
      image: ghcr.io/elfhosted/simple-proxy:rolling@sha256:a2ea32012ca4a04fdb185a032ac95fd76133acafb8dc75a52fa18c9bbc6d703e
  initContainers:
    setup-warp: *setup_warp
  addons:
    vpn:
      enabled: true
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      env:
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8
        DNS_KEEP_NAMESERVER: "on"
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        VPN_TYPE: wireguard
        VPN_SERVICE_PROVIDER: custom
        FIREWALL_INPUT_PORTS: "7777,3000"
        WIREGUARD_MTU: "1280"
        VPN_ENDPOINT_PORT: "2408"
        DOT: "off"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      volumeMounts:
      - mountPath: /shared
        name: shared

webstreamr:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/webstreamr
    tag: v0.40.3@sha256:ee21ab9ff9003ffee56df47865dcb06b757e1f499f77e11ede853de264816107
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: webstreamr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Webstreamr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/webstreamr.png"        
    elfbot.elfhosted.com/category: Consume Media
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,webstreamr-env,elfbot-webstreamr"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    tmp:
      enabled: true
      type: emptyDir
      mountPath: /tmp
  resources:
    requests:
      cpu: 10m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 51546
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 51546
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /health
          port: 51546
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10
    startup:
      custom: true
      enabled: true
      spec:
        failureThreshold: 30
        httpGet:
          path: /health
          port: 51546
        initialDelaySeconds: 30
        periodSeconds: 10
        timeoutSeconds: 10             
  envFrom:
  - configMapRef:
      name: webstreamr-env
  - secretRef:
      name: webstreamr-env      
  - configMapRef:
      name: elfbot-webstreamr
      optional: true
  addons:
    vpn:
      enabled: true # in case we ever need it
      gluetun:
        image:
          repository: thrnz/docker-wireguard-pia
          tag: latest
      env:
        IPTABLES_BACKEND: nft
        KILLSWITCH: "true"
        LOCAL_NETWORK: 10.0.0.0/8
        LOC: de-frankfurt
        PORT_FORWARDING: "0"
        PORT_PERSIST: "1"
        NFTABLES: "1"
        VPNDNS: "0"
      envFrom:
      - secretRef:
          name: webstreamr-vpn
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config

recyclarr:
  enabled: false
  image:
    repository: ghcr.io/recyclarr/recyclarr
    tag: latest@sha256:759540877f95453eca8a26c1a93593e783a7a824c324fbd57523deffb67f48e1
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: recyclarr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Recyclarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/recyclarr.png"        
    elfbot.elfhosted.com/category: Tools
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-recyclarr"
    strategy:
    rollingUpdate:
      unavailable: 1
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 100Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9898
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: recyclarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: recyclarr-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-recyclarr
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: recyclarr
      - mountPath: /tmp
        name: tmp
    copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # If we don't already have an example config, create one
        if [ ! -f /config/recyclarr.yaml ];
        then
          cp /bootstrap/recyclarr.yaml /config/
        fi
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: recyclarr
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true
  additionalContainers:
    podinfo:
      image: stefanprodan/podinfo # used to run probes from gatus
    sync:
      image: ghcr.io/recyclarr/recyclarr:latest@sha256:759540877f95453eca8a26c1a93593e783a7a824c324fbd57523deffb67f48e1
      command:
      - /bin/bash
      - -c
      - |
        recyclarr sync
        sleep infinity
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: recyclarr
      envFrom:
      - configMapRef:
          name: recyclarr-env

zurg: &app_zurg
  enabled: false
  # Avoid search expansion DNS queries against coredns for every RD API request 
  dnsConfig:
    options:
      - name: ndots
        value: "2"
  podLabels:
    app.elfhosted.com/name: zurg
  podAnnotations:
    elfbot.elfhosted.com/name: "Zurg"
    elfbot.elfhosted.com/icon: "fas fa-robot"  
    elfbot.elfhosted.com/category: Manage Media    
  image:
    repository: ghcr.io/elfhosted/zurg-rc
    tag: 2025.07.29.0047-nightly@sha256:1a42b75a1758065b7250033758a4c957dece6510d5345e3a21255adc6ce805f7
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-zurg,zurg-env,gluetun-config,elfbot-plex,elfbot-emby,elfbot-jellyfin"
    strategy: Recreate
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 32Mi
    limits:
      cpu: 1
      memory: 2Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9999
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: zurg
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: zurg
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs          
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: zurg-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-zurg
          optional: true
    shared:
      enabled: true
      mountPath: /shared
      type: emptyDir
      volumeSpec:
        medium: Memory
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755
  envFrom:
  - configMapRef:
      name: zurg-env # this is here so we can use env vars to detect whether to enable warp
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: zurg
      - mountPath: /tmp
        name: tmp
    copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # We need a /config/logs folder
        mkdir -p /config/logs

        # If we don't already have an example config, create one
        if [[ ! -f /config/config.yml ]];
        then
          cp /bootstrap/config.yml /config/
        fi

        # If we don't already have an example plex_update, create one
        if [[ ! -f /config/plex_update.sh ]];
        then
          cp /bootstrap/plex_update.sh /config/
        fi
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: zurg
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true
    setup:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        # run the setup script from the configmap, so that we can make templated changes
        bash /bootstrap/setup.sh
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: zurg
      - name: example-config
        mountPath: "/bootstrap/"
  addons:
    vpn: &zurg_addons_vpn
      enabled: false # in case we ever need it
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      envFrom:
      - configMapRef:
          name: gluetun-config
          optional: true
      - configMapRef:
          name: zurg-env # this is here so we can use env vars to detect whether to enable warp
      env:
        DOT: "off"
        FIREWALL_INPUT_PORTS: "9999" # 9999 is for zurg
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        HEALTH_SERVER_ADDRESS: "127.0.0.1:9991"
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config
      scripts:
        up: |-
          #!/bin/ash
          echo "connected" > /shared/vpnstatus

        down: |-
          #!/bin/ash
          echo "disconnected" > /shared/vpnstatus
  probes:
    startup:
      spec:
        initialDelaySeconds: 0
        timeoutSeconds: 1
        ## This means it has a maximum of 5*120=720 seconds to start up before it fails
        periodSeconds: 5
        failureThreshold: 120

zurggluetun:
  <<: *app_zurg
  enabled: false
  podLabels:
    app.elfhosted.com/name: zurg
    app.elfhosted.com/class: debrid
  podAnnotations:
    elfbot.elfhosted.com/name: "Zurg"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/zurg.png"     
    elfbot.elfhosted.com/category: Manage Media 
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-zurg,zurg-gluetun-config,zurg-env"
  service:
    main:
      nameOverride: zurg
      enabled: true # necessary for probes, but probes aren't working with vpn addon currently
  env:
    WAIT_FOR_VPN: "true"
  addons:
    vpn:
      enabled: true
      <<: *zurg_addons_vpn
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      envFrom:
      - configMapRef:
          name: gluetun-config

zurgranger:
  <<: *app_zurg
  podLabels:
    app.elfhosted.com/name: zurg
    app.elfhosted.com/class: dedicated
  podAnnotations:
    elfbot.elfhosted.com/name: "Zurg"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/zurg.png"   
    elfbot.elfhosted.com/category: Manage Media 
    kubernetes.io/egress-bandwidth: "500M"
  enabled: false
  automountServiceAccountToken: false
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-zurg"
  affinity: *dedicated_affinity # force zurg to go onto the dedicated nodes
  resources: *ranger_zurg_resources

plexdebrid: &app_plexdebrid
  enabled: false
  # podLabels:
  #   app.elfhosted.com/name: plexdebrid
  image:
    repository: ghcr.io/elfhosted/plex-debrid
    tag: rolling@sha256:0c0251d2aef532ba62660b719b7e37e72b4eb262ca18e21d68b9509d305e12a1
  podLabels:
    app.elfhosted.com/name: plex-debrid    
  podAnnotations:
    elfbot.elfhosted.com/name: "plex_debrid"
    elfbot.elfhosted.com/icon: "fas fa-film" 
    elfbot.elfhosted.com/category: Manage Downloads     
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-plex-debrid"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # doesn't work because of s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  env:
    PUID: 568
    PGID: 568
  resources:
    requests:
      cpu: 2m
      memory: 100Mi
    limits:
      cpu: 500m
      memory: 3Gi
  ingress:
    main:
      enabled: false
  envFrom:
  - secretRef:
      name: plex-debrid-env
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: plex-debrid
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-plex-debrid
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: plex-debrid
      - mountPath: /tmp
        name: tmp

clidebrid: &app_clidebrid
  enabled: false
  podLabels:
    app.elfhosted.com/name: cli-debrid
  podAnnotations:
    elfbot.elfhosted.com/name: "CLI Debrid"
    elfbot.elfhosted.com/icon: "fas fa-terminal"      
    elfbot.elfhosted.com/category: Manage Downloads
  image:
    repository: ghcr.io/elfhosted/cli_debrid-dev
    tag: v0.6.98@sha256:e4448c72c4571bc4512ccda8b83e02d4bfa1e1aa7051f6ea919f5b872bfcd4e2 
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-cli-debrid,cli-debrid-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work because of s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  env:
    PUID: 568
    PGID: 568
  envFrom:
  - configMapRef:
      name: cli-debrid-env
  - configMapRef:
      name: elfbot-cli-debrid
      optional: true        
  resources:
    requests:
      cpu: 2m
      memory: 100Mi
    limits:
      cpu: 500m
      memory: 3Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 5000
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /user/
      subPath: cli-debrid
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /user/logs
      subPath: cli-debrid
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs          
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-cli-debrid
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: cli-debrid
      - mountPath: /tmp
        name: tmp
    setup:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x

        # Create directory structure if it doesn't exist yet
        mkdir -p /storage/symlinks/movies
        mkdir -p /storage/symlinks/movies-4k
        mkdir -p /storage/symlinks/movies-anime
        mkdir -p /storage/symlinks/series
        mkdir -p /storage/symlinks/series-4k
        mkdir -p /storage/symlinks/series-anime
      volumeMounts:
      - mountPath: /storage/symlinks
        name: symlinks
      resources: *default_resources
      securityContext: *default_securitycontext           

puter:
  enabled: false
  podLabels:
    app.elfhosted.com/name: puter
  podAnnotations:
    elfbot.elfhosted.com/name: "Puter"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/puter.png"    
    elfbot.elfhosted.com/category: Tools  
  image:
    repository: ghcr.io/elfhosted/puter
    tag: v2.5.1@sha256:4566493190067df16091134e9fa845ffa21f6e517874eb146cb4bca9c4177ca9
  priorityClassName: tenant-normal
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-puter"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: false # doesn't work because of s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  env:
    PUID: 568
    PGID: 568
  resources:
    requests:
      cpu: 2m
      memory: 100Mi
    limits:
      cpu: 500m
      memory: 3Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 4100
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config/
      subPath: puter
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-puter
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: puter
      - mountPath: /tmp
        name: tmp

codeserver:
  enabled: false
  # runtimeClassName: kata
  image:
    repository: ghcr.io/elfhosted/codeserver
    tag: 4.102.2@sha256:66c50a8f234818dd64d0365165ba64b0d6e6608c93a9aa746d0b96431315b5be
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: codeserver  
  podAnnotations:
    elfbot.elfhosted.com/name: "Code Server"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/code-server.png"
    elfbot.elfhosted.com/category: Tools        
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-codeserver"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true # doesn't work because of s6
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    fsGroup: 568
    # runAsUser: 568
    # runAsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 15m
      memory: 200Mi
    limits:
      cpu: 2
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config # no subpath, codeserver wants to see all
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-plex-debrid
          optional: true
    example-config:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: codeserver-config
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: codeserver
      - mountPath: /tmp
        name: tmp
    copy-example-config:
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        # If we don't already have an example config, create one
        mkdir -p /config/.config/code-server/
        if [ ! -f /config/.config/code-server/config.yaml ];
        then
          cp /bootstrap/config.yaml /config/.config/code-server/
        fi
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: codeserver
      - name: example-config
        mountPath: "/bootstrap/"
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true

doplarr: &app_doplarr
  enabled: false
  image:
    repository: ghcr.io/elfhosted/doplarr
    tag: v3.6.3@sha256:7703328fc7f9f4190606ba9f95e867a64db79bd06c19e923a83ad6f939f89097
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: doplarr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Doplarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/doplarr.png"  
    elfbot.elfhosted.com/category: Manage Downloads      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-doplarr,doplarr-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: false
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 100m
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3001
  envFrom:
  - configMapRef:
      name: elfbot-doplarr
      optional: true

profilarr:
  enabled: false
  hostAliases:
  - ip: "127.0.0.1"
    hostnames:  
    - "backend" 
  image:
    repository: ghcr.io/elfhosted/profilarr-frontend
    tag: v1.0.1@sha256:1f2165783bc2030da7ca84f8b2aa4d709a24d51f05cd1de33cb3b4a438d399d0
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: profilarr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Profilarr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/profilarr.png" 
    elfbot.elfhosted.com/category: Manage Downloads       
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-profilarr,profilarr-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: false
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 100m
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3000
  envFrom:
  - configMapRef:
      name: elfbot-profilarr
      optional: true
  persistence:
    tmp: *tmp
    logs:
      enabled: true
      type: custom
      mountPath: /app/logs
      subPath: profilarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs
    npm:
      enabled: true
      type: emptyDir
      mountPath: /.npm
      sizeLimit: 1Gi          
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: profilarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-profilarr
          optional: true   
    app:
      enabled: "true"
      type: emptyDir
      mountPath: /app
      volumeSpec:
        medium: Memory           
  additionalContainers:
    backend:
      image: ghcr.io/elfhosted/profilarr-backend:v1.0.1@sha256:b1f776ae78836917d2808bd4ab3a0311be58c2627b109e529e052c678c74e8c3     
      volumeMounts:
      - name: config
        mountPath: /config
        subPath: profilarr
  initContainers:
    setup:
      image: ghcr.io/elfhosted/profilarr-frontend:v1.0.1@sha256:1f2165783bc2030da7ca84f8b2aa4d709a24d51f05cd1de33cb3b4a438d399d0
      command:
      - /bin/bash
      - -c
      - |
        # copy the image's build-cache directory into the emptyDir
        cp /app/* /tmp -rfp
      volumeMounts:
      - mountPath: /tmp
        name: app
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: profilarr
      - mountPath: /tmp
        name: tmp

pulsarr: &app_pulsarr
  enabled: false
  image:
    repository: ghcr.io/elfhosted/pulsarr
    tag: v0.4.17@sha256:c84cb49b7e990f3c832576b4cfb219660e5c2d37b9719e1fd0324f4607fcde08
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: pulsarr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Pulsarr"
    elfbot.elfhosted.com/icon: "fas fa-broadcast-tower"      
    elfbot.elfhosted.com/category: Manage Downloads  
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-pulsarr,pulsarr-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: false
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  persistence:
    backup: *backup
    tmp: *tmp
    logs:
      enabled: true
      type: custom
      mountPath: /app/data/logs
      subPath: pulsarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs    
    config:
      enabled: true
      type: custom
      mountPath: /app/data
      subPath: pulsarr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-pulsarr
          optional: true  
    app:
      enabled: "true"
      type: emptyDir
      mountPath: /app
      volumeSpec:
        medium: Memory                
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 1
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 3003
  envFrom:
  - configMapRef:
      name: pulsarr-env
  - configMapRef:
      name: elfbot-pulsarr
      optional: true      
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: pulsarr
      - mountPath: /tmp
        name: tmp
    setup:
      image: ghcr.io/elfhosted/pulsarr:v0.4.17@sha256:c84cb49b7e990f3c832576b4cfb219660e5c2d37b9719e1fd0324f4607fcde08
      command:
      - /bin/ash
      - -c
      - |
        # copy the image's build-cache directory into the emptyDir
        cp /app/* /tmp -rfp
      volumeMounts:
      - mountPath: /tmp
        name: app
  additionalContainers:
    apprise-api:
      image: ghcr.io/elfhosted/apprise-api:v1.2.0@sha256:ed6e963a2cdd1bdef63c51e82ca7b8bd2549f285f2e0510ea78d6f0adac40588
      volumeMounts:
      - name: config
        mountPath: /config
        subPath: pulsarr/apprise
      env:
        PUID: 568
        PGID: 568
        APPRISE_STATEFUL_MODE: simple
        APPRISE_WORKER_COUNT: "1"

requestrr:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/requestrr
    tag: v2.1.6@sha256:d9daf341af2608f8351ae4cfdb6f685c1ea675e18b88860d0bfbc6343202402b
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: requestrr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Requestrr"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/requestrr.png"  
    elfbot.elfhosted.com/category: Manage Downloads      
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-requestrr,requestrr-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: false
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      mountPath: /app/config
      subPath: requestrr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-requestrr
          optional: true
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 100m
      memory: 1Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 4545
  envFrom:
  - configMapRef:
      name: elfbot-requestrr
      optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: requestrr
      - mountPath: /tmp
        name: tmp

debridav: &app_debridav
  enabled: false
  priorityClassName: tenant-normal
  podLabels:
    app.elfhosted.com/name: debridav  
  podAnnotations:
    elfbot.elfhosted.com/name: "DebriDav"
    elfbot.elfhosted.com/icon: "fas fa-cloud"
    elfbot.elfhosted.com/category: Manage Downloads      
  image:
    repository: ghcr.io/elfhosted/debridav
    tag: 0.10.1@sha256:67748eff91c1c318827284bb31a9f39c2ce10b22e29e58ec4f65659152fd8cfe
  imagePullSecrets:
  - name: ghcr-io-elfhosted    
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-debridav,debridav-env,elfbot-plex,elfbot-jellyfin,elfbot-emby"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    <<: *storagemounts
    tmp: *tmp
    backup: *backup
    dev-shm:
      enabled: "true"
      type: emptyDir
      volumeSpec:
        medium: Memory    
    config:
      enabled: true
      type: custom
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs          
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-debridav
          optional: true    
    import:
      enabled: true
      type: emptyDir
      mountPath: /import
      sizeLimit: 1Gi                   
  envFrom:
  - configMapRef:
      name: debridav-env
  - configMapRef:
      name: elfbot-debridav
      optional: true      
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080      
  probes:
    liveness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /actuator/health/liveness
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10
    readiness:
      custom: true
      enabled: true
      spec:
        failureThreshold: 5
        httpGet:
          path: /actuator/health/readiness
          port: 8080
        initialDelaySeconds: 30
        periodSeconds: 120
        timeoutSeconds: 10         
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 512Mi
    limits:
      cpu: 1
      memory: 2Gi
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: debridav
      - mountPath: /tmp
        name: tmp  
    # Only trigger this when moving to database
    setup-postgres:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        mkdir -p /config/database
        mkdir -p /config/backups
        chown elfie:elfie /config/database -R
      volumeMounts:
      - mountPath: /config
        name: config
        subPath: debridav
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault
    restart-with-plex:
      image: ghcr.io/elfhosted/plex:1.41.9.9961-46083195d@sha256:f273e344e77e6717254c850df69dcd59968b09f8bb243236bd7afca22432f01a
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when plex is updated"  
    restart-with-jellyfin:
      image: ghcr.io/elfhosted/jellyfin-dev:10.10.7@sha256:142d72610fabb7a9ecdf98ffaf035c3cd52236eeab1671d9441f055e4cfc8799
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when jellyfin is updated"  
    restart-with-emby:
      image: ghcr.io/elfhosted/emby:4.9.1.12@sha256:aabb6aa43bc0b051a3c667aa8f167fc8f35c4852990c595795b55a92f3a02cf8
      command:
      - /bin/bash
      - -c
      - |
        echo "This pod only exists to cause a restart when emby is updated"   
  additionalContainers:
    database:
      image: postgres:17-alpine
      args:
      - -c
      - shared_buffers=500MB
      - -c
      - work_mem=4MB
      - -c
      - effective_cache_size=1GB
      - -c
      - max_connections=310
      env:
        - name: POSTGRES_PASSWORD
          value: debridav
        - name: POSTGRES_DB
          value: debridav
        - name: POSTGRES_USER
          value: debridav
      volumeMounts:
      - mountPath: /var/lib/postgresql/data
        name: config
        subPath: debridav/database
      - mountPath: /dev/shm
        name: dev-shm
      resources:
        requests:
          cpu: 0m
          memory: 1Mi
        limits:
          cpu: 500m
          memory: 8Gi
    fakearr:
      image: ghcr.io/elfhosted/fakearr:rolling@sha256:9734625ab6bc3f669d5ed5d8d58c6acd45000c068acfc36807c5c97f03531bbf
      envFrom:
      - configMapRef:
          name: debridav-env      
      - configMapRef:      
          name: elfbot-debridav
          optional: true  
      volumeMounts:
      - name: tmp
        mountPath: /tmp    
          
rclonedebridlink:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/davdebrid
    tag: v1.2.2@sha256:6571776a022a36889d1cc8392440ad58fa2654535e82b9741f1c287e045c7fd0
  priorityClassName: tenant-normal
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podLabels:
    app.elfhosted.com/name: debridlink
  podAnnotations:
    elfbot.elfhosted.com/name: "DebridLink"
    elfbot.elfhosted.com/icon: "fas fa-link" 
    elfbot.elfhosted.com/category: Manage Downloads     
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-debridlink,debridlink-env"
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: false
    readOnlyRootFilesystem: true
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  persistence:
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: debridlink
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
  envFrom:
  - configMapRef:
      name: debridlink-env
  - configMapRef:
      name: elfbot-debridlink
      optional: true
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 100m
      memory: 100Mi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8080


rclonealldebrid:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/rclone
    tag: 1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
  command:
  - /debrid-provider.sh
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-alldebrid,alldebrid-config,gluetun-config"
  podAnnotations:
    kubernetes.io/egress-bandwidth: "150M"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    cache:
      enabled: true
      type: emptyDir
      mountPath: /home/elfie/.cache
      sizeLimit: 1Gi
    config: 
      enabled: "true"
      type: emptyDir
      mountPath: /config
    bootstrap:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: alldebrid-config
    tinyproxy-conf:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: alldebrid-tinyproxy-conf 
  additionalContainers:
    # Use this to provied proxied access to mediaflowproxy
    tinyproxy:
      image: docker.io/kalaksi/tinyproxy
      volumeMounts:
      - name: tinyproxy-conf
        mountPath: /etc/tinyproxy/tinyproxy.conf
        subPath: tinyproxy.conf                      
  initContainers:
    setup:
      image: ghcr.io/elfhosted/rclone:1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
      command:
      - /bin/ash
      - -c
      - |
        set -x

        # Create directory structure

        OBSCURED_PASS=$(rclone obscure doesntmatter)
        cp /bootstrap/rclone-debrid-provider.conf /config/
        sed -i "s/REPLACEUSER/$USER/" /config/rclone-debrid-provider.conf
        sed -i "s/REPLACEPASS/$OBSCURED_PASS/" /config/rclone-debrid-provider.conf
        
      volumeMounts:
      - mountPath: /config
        name: config
      - mountPath: /bootstrap
        name: bootstrap
      resources: *default_resources
      securityContext: *default_securitycontext
      envFrom:
      - configMapRef:
          name: elfbot-alldebrid
          optional: true
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9999      
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 60Mi
    limits:
      cpu: 150m
      memory: 512Mi
  addons:
    vpn:
      enabled: true
      gluetun:
        image:
          repository: ghcr.io/elfhosted/gluetun
          tag: 3.40.0@sha256:59b0cc8a9412b9a4645d1f12dff0daba80b8be88acd1b5d1a0fb6dfa625eb9a5
      envFrom:
      - configMapRef:
          name: gluetun-config
      env:
        DOT: "off"
        FIREWALL_INPUT_PORTS: "9999,8888" # 9999 is for rclone, 8888 is tinyproxy
        HTTP_CONTROL_SERVER_PORT: "8000"
        HTTP_CONTROL_SERVER_ADDRESS: ":8000"
        HEALTH_SERVER_ADDRESS: "127.0.0.1:9991"
        FIREWALL_OUTBOUND_SUBNETS: 10.0.0.0/8,192.168.0.0/16,172.16.0.0/20
        DNS_KEEP_NAMESERVER: "on"        
      securityContext:
        privileged: true
        runAsUser: 0
        capabilities:
          add:
            - NET_ADMIN
            - SYS_MODULE
      config: # We have to set this to null so that we can override with our own config

rclonepremiumize:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/rclone
    tag: 1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
  command:
  - /debrid-provider.sh
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-premiumize,premiumize-config"
  podAnnotations:
    kubernetes.io/egress-bandwidth: "150M"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    cache:
      enabled: true
      type: emptyDir
      mountPath: /home/elfie/.cache
      sizeLimit: 1Gi
    config: 
      enabled: "true"
      type: emptyDir
      mountPath: /config
    bootstrap:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: premiumize-config
  initContainers:
    setup:
      image: ghcr.io/elfhosted/rclone:1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
      command:
      - /bin/ash
      - -c
      - |
        set -x

        # Create directory structure

        OBSCURED_PASS=$(rclone obscure "$PASS")
        cp /bootstrap/rclone-debrid-provider.conf /config/
        sed -i "s/REPLACEUSER/$USER/" /config/rclone-debrid-provider.conf
        sed -i "s/REPLACEPASS/$OBSCURED_PASS/" /config/rclone-debrid-provider.conf
        
      volumeMounts:
      - mountPath: /config
        name: config
      - mountPath: /bootstrap
        name: bootstrap
      resources: *default_resources
      securityContext: *default_securitycontext
      envFrom:
      - configMapRef:
          name: elfbot-premiumize
          optional: true
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9999      
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 60Mi
    limits:
      cpu: 150m
      memory: 512Mi

rclonetorbox:
  enabled: false
  priorityClassName: tenant-normal
  image:
    repository: ghcr.io/elfhosted/rclone
    tag: 1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
  command:
  - /debrid-provider.sh
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-torbox,torbox-config"
  podAnnotations:
    kubernetes.io/egress-bandwidth: "150M"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  automountServiceAccountToken: false
  persistence:
    cache:
      enabled: true
      type: emptyDir
      mountPath: /home/elfie/.cache
      sizeLimit: 1Gi
    # we'll run the obscure command and copy the config into here
    config: 
      enabled: "true"
      type: emptyDir
      mountPath: /config
    bootstrap:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: torbox-config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-torbox
          optional: true          
  initContainers:
    setup:
      image: ghcr.io/elfhosted/rclone:1.70.3@sha256:6f9fab07ff82e308c1152f119ace42d7fce3476ace0ee2631e123463ccaf22fd
      command:
      - /bin/ash
      - -c
      - |
        set -x

        # Create directory structure

        OBSCURED_PASS=$(rclone obscure "$PASS")
        cp /bootstrap/rclone-debrid-provider.conf /config/
        sed -i "s/REPLACEUSER/$USER/" /config/rclone-debrid-provider.conf
        sed -i "s/REPLACEPASS/$OBSCURED_PASS/" /config/rclone-debrid-provider.conf
        
      volumeMounts:
      - mountPath: /config
        name: config
      - mountPath: /bootstrap
        name: bootstrap
      - mountPath: /elfbot
        name: elfbot
      resources: *default_resources
      securityContext: *default_securitycontext
      envFrom:
      - configMapRef:
          name: elfbot-torbox
          optional: true

  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 9999
  envFrom:
  - configMapRef:
      name: elfbot-torbox
      optional: true              
  ingress:
    main:
      enabled: false
  resources:
    requests:
      cpu: 0m
      memory: 60Mi
    limits:
      cpu: 150m
      memory: 512Mi


decypharr: &app_decypharr
  enabled: false
  image:
    repository: ghcr.io/elfhosted/decypharr
    tag: v1.0.5@sha256:b0d539fe2217cce88979e65f6982afd872579a5fbc72140c06c36bfe0e2fdf3d
  priorityClassName: tenant-normal
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  podLabels:
      app.elfhosted.com/name: decypharr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Decypharr"
    elfbot.elfhosted.com/icon: "fas fa-robot"        
    elfbot.elfhosted.com/category: Manage Downloads
  # Avoid search expansion DNS queries against coredns for every RD API request
  dnsConfig:
    options:
      - name: ndots
        value: "2"  
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-decypharr,decypharr-example-config,elfbot-plex,elfbot-emby,elfbot-jellyfin"
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: false
    readOnlyRootFilesystem: true
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 0m
      memory: 1Mi
    limits:
      cpu: 1
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8282
  persistence:
    <<: *storagemounts
    config:
      enabled: true
      type: custom
      mountPath: /config
      subPath: decypharr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    logs:
      enabled: true
      type: custom
      mountPath: /config/logs
      subPath: decypharr
      volumeSpec:
        persistentVolumeClaim:
          claimName: logs     
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-decypharr
          optional: true                      
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: decypharr
      - mountPath: /tmp
        name: tmp        

channelsdvr:
  enabled: false
  image:
    repository: fancybits/channels-dvr
    tag: latest@sha256:284fed6f4ee5150d41d9a7f247a63e190f6f1c3a4e4bc740f029df6d36955d29
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: channelsdvr  
  podAnnotations:
    elfbot.elfhosted.com/name: "Channels DVR"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/channels-dvr.png"
    elfbot.elfhosted.com/category: Consume Media
    kubernetes.io/egress-bandwidth: "150M"
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-channelsdvr"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: true
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
    supplementalGroups:
    - 993
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 15m
      memory: 200Mi
    limits:
      cpu: 1
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8089
  persistence:
    <<: *storagemounts
    render-device: *streamer_render_device
    tmp: *tmp
    config:
      enabled: true
      type: custom
      mountPath: /channels-dvr
      subPath: channelsdvr
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-channelsdvr
          optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: channelsdvr
      - mountPath: /tmp
        name: tmp

wger:
  enabled: false
  image:
    repository: ghcr.io/elfhosted/wger
    tag: 2.4@sha256:9e02ff11353c20f801bdabc2c1058b8c890418841db491c6f87e420034dfd38c
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: wger  
  podAnnotations:
    elfbot.elfhosted.com/name: "Wger"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/wger.png"        
    elfbot.elfhosted.com/category: Tools
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-wger,wger-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
  podSecurityContext:
    fsGroup: 568
    runAsUser: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 15m
      memory: 200Mi
    limits:
      cpu: 1
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 8000
  persistence:
    tmp: *tmp
    backup: *backup
    config:
      enabled: true
      type: custom
      subPath: wger
      mountPath: /config
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-wger
          optional: true
    run: # may be necessary for nginx
      enabled: true
      type: emptyDir
      mountPath: /run
      sizeLimit: 1Gi          
  envFrom:
  - configMapRef:
      name: wger-env
  - configMapRef:
      name: elfbot-wger
      optional: true
  initContainers:
    a-fix-permissions:
      image: *tooling_image
      command:
      - /bin/bash
      - -c
      - |
        set -x
        set -e

        chown elfie:elfie /config -R

      volumeMounts:
      - mountPath: /config
        name: config
        subPath: wger
      securityContext:
        runAsUser: 0
        seccompProfile:
          type: RuntimeDefault    
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: wger
      - mountPath: /tmp
        name: tmp
  additionalContainers:
    ngnix:
      image: nginxinc/nginx-unprivileged
      volumeMounts:
        - name: config
          subPath: wger/media
          mountPath: /usr/share/nginx/html/media    
        - name: config
          subPath: wger/static
          mountPath: /usr/share/nginx/html/static      
        - mountPath: /tmp
          name: tmp
        - mountPath: /run
          name: run
      resources: *default_resources
      securityContext: *default_securitycontext    
    database:
      image: postgres:17-alpine
      env:
        POSTGRES_PASSWORD: wger
        POSTGRES_USER: wger
        POSTGRES_DB: wger
      volumeMounts:
        - mountPath: /var/lib/postgresql/data
          name: config
          subPath: wger/postgresql/database
      resources:
        requests:
          cpu: 15m
          memory: 200Mi
        limits:
          cpu: 500m
          memory: 4Gi
    redis:
      image: docker.io/redis:7.4-alpine@sha256:bb186d083732f669da90be8b0f975a37812b15e913465bb14d845db72a4e3e08
      envFrom:
      - configMapRef:
          name: wger-env
      volumeMounts:
        - name: config
          subPath: wger/redis
          mountPath: /data         
      resources:
        requests:
          cpu: 15m
          memory: 200Mi
        limits:
          cpu: 500m
          memory: 4Gi
    celery-worker:
      image: ghcr.io/elfhosted/wger:2.4@sha256:9e02ff11353c20f801bdabc2c1058b8c890418841db491c6f87e420034dfd38c
      command:
      - /start-worker
      volumeMounts:
        - name: config
          subPath: wger/media
          mountPath: /home/wger/media    
        - name: config
          subPath: wger/static
          mountPath: /home/wger/static
      envFrom:
      - configMapRef:
          name: wger-env
      - configMapRef:
          name: elfbot-wger
          optional: true          
    celery-beat:
      image: ghcr.io/elfhosted/wger:2.4@sha256:9e02ff11353c20f801bdabc2c1058b8c890418841db491c6f87e420034dfd38c
      command:
      - /start-beat      
      volumeMounts:
        - name: config
          subPath: wger/beat
          mountPath: /home/wger/beat
      envFrom:
      - configMapRef:
          name: wger-env
      - configMapRef:
          name: elfbot-wger
          optional: true       
    database-backup:
      image: *tooling_image
      env:
        - name: POSTGRES_PASSWORD
          value: wger
        - name: POSTGRES_DATABASE
          value: wger
        - name: POSTGRES_USER
          value: wger
      volumeMounts:
      - mountPath: /backup
        name: backup
        subPath: wger
      command:
      - /usr/bin/dumb-init
      - /bin/bash
      - -c
      - |

        set +e # for debug
        sleep 2m # give postgres time to start up
        while true
        do
          now=$(date +"%s_%Y-%m-%d")
          PGPASSWORD=$POSTGRES_PASSWORD pg_dump -U $POSTGRES_USER -h localhost -d $POSTGRES_DATABASE -F c -f /backup/${now}_${POSTGRES_DATABASE}.psql
          sleep 1d
        done       

immich:
  enabled: false
  image:
    repository: ghcr.io/immich-app/immich-server
    tag: v1.137.3@sha256:e517f806457057d44695152a0af2dfa094225a7d85eb37f518925e68864c658d
  priorityClassName: tenant-normal
  podLabels:
      app.elfhosted.com/name: immich  
  podAnnotations:
    elfbot.elfhosted.com/name: "Immich"
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/immich.png" 
    elfbot.elfhosted.com/category: Consume Media       
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "elfbot-all,elfbot-immich,immich-env"
  affinity: *standard_affinity
  tolerations: *standard_tolerations
  securityContext:
    runAsUser: 568
    runAsGroup: 568
    privileged: true
  podSecurityContext:
    fsGroup: 568
    fsGroupChangePolicy: "Always"
    seccompProfile:
      type: RuntimeDefault
    supplementalGroups:
    - 993
  automountServiceAccountToken: false
  resources:
    requests:
      cpu: 15m
      memory: 200Mi
    limits:
      cpu: 500m
      memory: 4Gi
  ingress:
    main:
      enabled: false
  service:
    main:
      enabled: true # necessary for probes
      ports:
        http:
          port: 2283
  persistence:
    <<: *storagemounts
    render-device: *streamer_render_device
    tmp: *tmp
    config:
      enabled: true
      type: custom
      subPath: immich
      volumeSpec:
        persistentVolumeClaim:
          claimName: config
    upload:
      enabled: true
      type: emptyDir
      mountPath: /usr/src/app/upload
      sizeLimit: 1Gi
    upload-encoded:
      enabled: true
      type: emptyDir
      mountPath: /usr/src/app/upload/encoded-video
      sizeLimit: 1Gi
    elfbot:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: elfbot-immich
          optional: true
  envFrom:
  - configMapRef:
      name: immich-env
  - configMapRef:
      name: elfbot-immich
      optional: true
  initContainers:
    bootstrap:
      <<: *bootstrap
      volumeMounts:
      - mountPath: /etc/elfbot
        name: elfbot
      - mountPath: /storage/backup
        name: backup
      - mountPath: /config
        name: config
        subPath: immich
      - mountPath: /tmp
        name: tmp
  additionalContainers:
    ml:
      image: ghcr.io/immich-app/immich-machine-learning:v1.131.2
      envFrom:
      - configMapRef:
          name: immich-env
      resources:
        requests:
          cpu: 15m
          memory: 200Mi
        limits:
          cpu: 500m
          memory: 4Gi
    database:
      image: ghcr.io/immich-app/postgres:14-vectorchord0.3.0-pgvectors0.2.0
      env:
        POSTGRES_INITDB_ARGS: '--data-checksums'
        POSTGRES_PASSWORD: immich
        POSTGRES_USER: immich
        POSTGRES_DB: immich
      volumeMounts:
        - name: config
          subPath: immich/database
          mountPath: /var/lib/postgresql/data
      resources:
        requests:
          cpu: 15m
          memory: 200Mi
        limits:
          cpu: 500m
          memory: 4Gi
    redis:
      image: docker.io/redis:7.4-alpine@sha256:bb186d083732f669da90be8b0f975a37812b15e913465bb14d845db72a4e3e08
      envFrom:
      - configMapRef:
          name: immich-env
      resources:
        requests:
          cpu: 15m
          memory: 200Mi
        limits:
          cpu: 500m
          memory: 4Gi

kubernetesdashboard:

  ## Name of Priority Class of pods
  priorityClassName: "tenant-normal"

  ## Pod resource requests & limits
  resources:
    requests:
      cpu: 0m
      memory: 64Mi
    limits:
      cpu: 1
      memory: 256Mi

  extraArgs:
    - --enable-skip-login
    - --enable-insecure-login
    - --system-banner=Built</A> with  by <A HREF="https://funkypenguin.co.nz">@funkypenguin</A> and friends (<I><A HREF="https://chat.funkypenguin.co.nz">join us!</A></I>)

  ## Serve application over HTTP without TLS
  ##
  ## Note: If set to true, you may want to add --enable-insecure-login to extraArgs
  protocolHttp: true

  # Global dashboard settings
  settings:
    ## Cluster name that appears in the browser window title if it is set
    clusterName: "ElfHosted"
    # defaultNamespace: "{{ .Release.Namespace }}"
    # namespaceFallbackList: [ "{{ .Release.Namespace }}" ]

    ## Max number of items that can be displayed on each list page
    itemsPerPage: 10
    ## Number of seconds between every auto-refresh of logs
    logsAutoRefreshTimeInterval: 5
    ## Number of seconds between every auto-refresh of every resource. Set 0 to disable
    resourceAutoRefreshTimeInterval: 5
    ## Hide all access denied warnings in the notification panel
    disableAccessDeniedNotifications: true

  ## Metrics Scraper
  ## Container to scrape, store, and retrieve a window of time from the Metrics Server.
  ## refs: https://github.com/kubernetes-sigs/dashboard-metrics-scraper
  metricsScraper:
    ## Wether to enable dashboard-metrics-scraper
    enabled: true
    image:
      repository: kubernetesui/metrics-scraper
      tag: v1.0.9
    resources: {}
    ## SecurityContext especially for the kubernetes dashboard metrics scraper container
    ## If not set, the global containterSecurityContext values will define these values
    # containerSecurityContext:
    #   allowPrivilegeEscalation: false
    #   readOnlyRootFilesystem: true
    #   runAsUser: 1001
    #   runAsGroup: 2001
  #  args:
  #    - --log-level=info
  #    - --logtostderr=true

  # Don't auto-create RBAC for us, we'll do it manually
  rbac:
    create: false

  serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: kubernetes-dashboard

# optional but disabled by default to prevent errors


gluetun:
  enabled: false # just to avoid errors
cometproxystreaming:
  enabled: false
mediafusionproxystreaming:
  enabled: false
elfassesment:
  enabled: false

plexhobbit:
  <<: *app_plex
  podAnnotations: 
    <<: *hobbit_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/plex.png"
    elfbot.elfhosted.com/name: "Plex"
    elfbot.elfhosted.com/category: Consume Media
  resources: *hobbit_streamer_resources
  persistence:
    <<: *app_plex_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

jellyfinhobbit:
  <<: *app_jellyfin
  podAnnotations: 
    <<: *hobbit_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jellyfin.png"
    elfbot.elfhosted.com/name: "Jellyfin"
    elfbot.elfhosted.com/category: Consume Media      
  resources: *hobbit_streamer_resources
  persistence:
    <<: *app_jellyfin_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: jellyfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

embyhobbit:
  <<: *app_emby
  podAnnotations: 
    <<: *hobbit_streamer_podAnnotations
    elfbot.elfhosted.com/name: "Emby"
    elfbot.elfhosted.com/category: Consume Media
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/emby.png"  
  resources: *hobbit_streamer_resources
  persistence:
    <<: *app_emby_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: emby
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

plexranger:
  <<: *app_plex
  persistence:
    <<: *app_plex_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g
  podAnnotations: 
    <<: *ranger_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/plex.png"
    elfbot.elfhosted.com/name: "Plex"
    elfbot.elfhosted.com/category: Consume Media    
  resources: *ranger_streamer_resources

plexhalfling:
  <<: *app_plex
  persistence:
    <<: *app_plex_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  
  podAnnotations: 
    <<: *halfling_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/plex.png"
    elfbot.elfhosted.com/name: "Plex"
    elfbot.elfhosted.com/category: Consume Media     
  resources: *halfling_streamer_resources

jellyfinhalfling:
  <<: *app_jellyfin
  podAnnotations: 
    <<: *halfling_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jellyfin.png"
    elfbot.elfhosted.com/name: "Jellyfin"
    elfbot.elfhosted.com/category: Consume Media      
  resources: *halfling_streamer_resources
  persistence:
    <<: *app_jellyfin_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: jellygfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

embyhalfling:
  <<: *app_emby
  podAnnotations: 
    <<: *halfling_streamer_podAnnotations
    elfbot.elfhosted.com/name: "Emby"
    elfbot.elfhosted.com/category: Consume Media
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/emby.png"    
  resources: *halfling_streamer_resources
  persistence:
    <<: *app_emby_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: emby
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

plexnazgul:
  <<: *app_plex
  persistence:
    <<: *app_plex_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: plex
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  
  podAnnotations: *nazgul_streamer_podAnnotations
  resources: *nazgul_streamer_resources

jellyfinnazgul:
  <<: *app_jellyfin
  podAnnotations: 
    <<: *nazgul_streamer_podAnnotations
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/jellyfin.png"
    elfbot.elfhosted.com/name: "Jellyfin"
    elfbot.elfhosted.com/category: Consume Media      
  resources: *nazgul_streamer_resources
  persistence:
    <<: *app_jellyfin_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: jellyfin
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

embynazgul:
  <<: *app_emby
  podAnnotations: 
    <<: *nazgul_streamer_podAnnotations
    elfbot.elfhosted.com/name: "Emby"
    elfbot.elfhosted.com/category: Consume Media
    elfbot.elfhosted.com/icon: "https://icons.elfhosted.com/emby.png"  
  resources: *nazgul_streamer_resources
  persistence:
    <<: *app_emby_persistence
    transcode:
      enabled: true
      type: custom
      mountPath: /transcode
      subPath: emby
      volumeSpec:
        persistentVolumeClaim:
          claimName: transcode-50g  

# We use these to set aside resources for dedicated bundles
streamer: &app_resource_reserver
  enabled: false
  priorityClassName: tenant-low # allow kubernetes to evict these pods first
  image:
    repository: ghcr.io/elfhosted/tooling
    tag: focal-20240530@sha256:458d1f3b54e9455b5cdad3c341d6853a6fdd75ac3f1120931ca3c09ac4b588de
  priorityClassName: tenant-low
  controller:
    annotations:
      configmap.reloader.stakater.com/reload: "tooling-scripts" # Reload the deployment every time the yaml config changes
  securityContext:
    seccompProfile:
      type: RuntimeDefault
    readOnlyRootFilesystem: true
  # we mount config to force the resource-reserver to run on the same node as the volumes
  persistence:
    config:
      enabled: true
      type: custom
      mountPath: /config
      volumeSpec:
        persistentVolumeClaim:
          claimName: config    
    tooling-scripts:
      enabled: "true"
      type: "custom"
      volumeSpec:
        configMap:
          name: tooling-scripts
          defaultMode: 0755          
  podSecurityContext:
    seccompProfile:
      type: RuntimeDefault
    runAsUser: 568
    runAsGroup: 568
    runAsNonRoot: true
    fsGroup: 568
    fsGroupChangePolicy: "OnRootMismatch"
  command:
  - /bin/bash
  - -c
  - |
    echo "This pod simple reserves contended resources for a tenant"

    sleep infinity
  affinity: *standard_affinity
  service:
    main:
      enabled: false
  probes:
    liveness:
      enabled: false
    startup:
      enabled: false
    readiness:
      enabled: false      
  resources:
    requests: 
      cpu: 100m
      memory: 500Mi
  initContainers:
    update-dns:  &update_dns_on_init
      image: *tooling_image
      imagePullPolicy: IfNotPresent
      command:
      - /usr/bin/dumb-init
      - /bin/bash
      - -c
      - /tooling-scripts/update-dns-on-init.sh
      env:
        - name: MY_NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: ELF_TENANT_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.labels['app.kubernetes.io/instance']
      envFrom:
      - secretRef:
          name: cloudflare-api-token
      volumeMounts:
      - mountPath: /tooling-scripts
        name: tooling-scripts
      securityContext:
        seccompProfile:
          type: RuntimeDefault
        readOnlyRootFilesystem: true
  additionalContainers:
    clean-up-dns:
      <<: *update_dns_on_init
      command:
      - /usr/bin/dumb-init
      - /bin/bash
      - -c
      - /tooling-scripts/clean-up-dns-on-termination.sh      

starter:
  enabled: false
  <<: *app_resource_reserver
  resources:
    requests: 
      cpu: 250m
      memory: 1Gi  

hobbit:
  enabled: false
  <<: *app_resource_reserver

ranger:
  enabled: false
  <<: *app_resource_reserver

halfling:
  enabled: false
  <<: *app_resource_reserver

nazgul:
  enabled: false
  <<: *app_resource_reserver

# This file must end on a single newline
